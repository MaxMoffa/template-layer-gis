(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.WindGl = {}));
})(this, (function (exports) { 'use strict';

    var WorkerClass = null;

    try {
        var WorkerThreads =
            typeof module !== 'undefined' && typeof module.require === 'function' && module.require('worker_threads') ||
            typeof __non_webpack_require__ === 'function' && __non_webpack_require__('worker_threads') ||
            typeof require === 'function' && require('worker_threads');
        WorkerClass = WorkerThreads.Worker;
    } catch(e) {} // eslint-disable-line

    function decodeBase64$1(base64, enableUnicode) {
        return Buffer.from(base64, 'base64').toString(enableUnicode ? 'utf16' : 'utf8');
    }

    function createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg) {
        var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
        var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
        var source = decodeBase64$1(base64, enableUnicode);
        var start = source.indexOf('\n', 10) + 1;
        var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
        return function WorkerFactory(options) {
            return new WorkerClass(body, Object.assign({}, options, { eval: true }));
        };
    }

    function decodeBase64(base64, enableUnicode) {
        var binaryString = atob(base64);
        if (enableUnicode) {
            var binaryView = new Uint8Array(binaryString.length);
            for (var i = 0, n = binaryString.length; i < n; ++i) {
                binaryView[i] = binaryString.charCodeAt(i);
            }
            return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
        }
        return binaryString;
    }

    function createURL(base64, sourcemapArg, enableUnicodeArg) {
        var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
        var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
        var source = decodeBase64(base64, enableUnicode);
        var start = source.indexOf('\n', 10) + 1;
        var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
        var blob = new Blob([body], { type: 'application/javascript' });
        return URL.createObjectURL(blob);
    }

    function createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg) {
        var url;
        return function WorkerFactory(options) {
            url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
            return new Worker(url, options);
        };
    }

    var kIsNodeJS = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

    function isNodeJS() {
        return kIsNodeJS;
    }

    function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
        if (isNodeJS()) {
            return createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg);
        }
        return createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg);
    }

    var WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgZnVuY3Rpb24gY2FsY01pbk1heChhcnJheSkgewogICAgbGV0IG1pbiA9IEluZmluaXR5OwogICAgbGV0IG1heCA9IEluZmluaXR5OwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCB2YWwgPSBhcnJheVtpXTsKICAgICAgaWYgKG1pbiA9PT0gSW5maW5pdHkpIHsKICAgICAgICBtaW4gPSB2YWw7CiAgICAgIH0gZWxzZSBpZiAobWF4ID09PSBJbmZpbml0eSkgewogICAgICAgIG1heCA9IHZhbDsKICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIG1heCk7CiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWluLCBtYXgpOwogICAgICB9IGVsc2UgewogICAgICAgIG1pbiA9IE1hdGgubWluKHZhbCwgbWluKTsKICAgICAgICBtYXggPSBNYXRoLm1heCh2YWwsIG1heCk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBbbWluLCBtYXhdOwogIH0KCiAgY29uc3QgY3R4ID0gc2VsZjsKICBjdHguYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsIGFzeW5jICh7IGRhdGE6IHBheWxvYWQgfSkgPT4gewogICAgY29uc3QgcmVuZGVyRm9ybSA9IHBheWxvYWRbMF07CiAgICBpZiAocmVuZGVyRm9ybSA9PT0gInJnIikgewogICAgICBjb25zdCB1RGF0YSA9IHBheWxvYWRbMV07CiAgICAgIGNvbnN0IHZEYXRhID0gcGF5bG9hZFsyXTsKICAgICAgY29uc3QgW3VNaW4sIHVNYXhdID0gY2FsY01pbk1heCh1RGF0YSk7CiAgICAgIGNvbnN0IFt2TWluLCB2TWF4XSA9IGNhbGNNaW5NYXgodkRhdGEpOwogICAgICBjb25zdCB2ZWxvY2l0eURhdGEgPSBuZXcgVWludDhBcnJheSh1RGF0YS5sZW5ndGggKiA0KTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1RGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IHIgPSAyNTUgKiAodURhdGFbaV0gLSB1TWluKSAvICh1TWF4IC0gdU1pbik7CiAgICAgICAgY29uc3QgZyA9IDI1NSAqICh2RGF0YVtpXSAtIHZNaW4pIC8gKHZNYXggLSB2TWluKTsKICAgICAgICB2ZWxvY2l0eURhdGEuc2V0KFtyLCBnLCAwLCAyNTVdLCBpICogNCk7CiAgICAgIH0KICAgICAgY3R4LnBvc3RNZXNzYWdlKFt2ZWxvY2l0eURhdGEuYnVmZmVyLCB1TWluLCB1TWF4LCB2TWluLCB2TWF4XSwgW3ZlbG9jaXR5RGF0YS5idWZmZXJdKTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbnN0IHNpbmdsZURhdGEgPSBwYXlsb2FkWzFdOwogICAgICBjb25zdCBbbWluLCBtYXhdID0gY2FsY01pbk1heChzaW5nbGVEYXRhKTsKICAgICAgY29uc3QgdmVsb2NpdHlEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2luZ2xlRGF0YS5sZW5ndGggKiA0KTsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaW5nbGVEYXRhLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgciA9IDI1NSAqIChzaW5nbGVEYXRhW2ldIC0gbWluKSAvIChtYXggLSBtaW4pOwogICAgICAgIHZlbG9jaXR5RGF0YS5zZXQoW3IsIDAsIDAsIDI1NV0sIGkgKiA0KTsKICAgICAgfQogICAgICBjdHgucG9zdE1lc3NhZ2UoW3ZlbG9jaXR5RGF0YS5idWZmZXIsIG1pbiwgbWF4XSwgW3ZlbG9jaXR5RGF0YS5idWZmZXJdKTsKICAgIH0KICB9KTsKCn0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFQcm9jZXNzZS5qcy5tYXAKCg==', 'data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0YVByb2Nlc3NlLmpzIiwic291cmNlcyI6WyJ3b3JrZXI6Ly93ZWItd29ya2VyL3V0aWxzL2NvbW1vbi50cyIsIndvcmtlcjovL3dlYi13b3JrZXIvd29ya2Vycy9EYXRhUHJvY2Vzc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNhbGNNaW5NYXgoYXJyYXk6IG51bWJlcltdKTogW251bWJlciwgbnVtYmVyXSB7XG4gIGxldCBtaW4gPSBJbmZpbml0eTtcbiAgbGV0IG1heCA9IEluZmluaXR5O1xuICAvLyBAZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM1NDQ0NzYvaG93LXRvLWZpbmQtbWF4LWFuZC1taW4taW4tYXJyYXktdXNpbmctbWluaW11bS1jb21wYXJpc29uc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsID0gYXJyYXlbaV07XG5cbiAgICBpZiAobWluID09PSBJbmZpbml0eSkge1xuICAgICAgbWluID0gdmFsO1xuICAgIH0gZWxzZSBpZiAobWF4ID09PSBJbmZpbml0eSkge1xuICAgICAgbWF4ID0gdmFsO1xuICAgICAgLy8gdXBkYXRlIG1pbiBtYXhcbiAgICAgIC8vIDEuIFBpY2sgMiBlbGVtZW50cyhhLCBiKSwgY29tcGFyZSB0aGVtLiAoc2F5IGEgPiBiKVxuICAgICAgbWluID0gTWF0aC5taW4obWluLCBtYXgpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWluLCBtYXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAyLiBVcGRhdGUgbWluIGJ5IGNvbXBhcmluZyAobWluLCBiKVxuICAgICAgLy8gMy4gVXBkYXRlIG1heCBieSBjb21wYXJpbmcgKG1heCwgYSlcbiAgICAgIG1pbiA9IE1hdGgubWluKHZhbCwgbWluKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KHZhbCwgbWF4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWw6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkZSh2YWw6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsICYmICFpc05hTih2YWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhzdG9wczogbnVtYmVyW10sIGlucHV0OiBudW1iZXIpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gc3RvcHMubGVuZ3RoIC0gMTtcbiAgbGV0IGxvd2VySW5kZXggPSAwO1xuICBsZXQgdXBwZXJJbmRleCA9IGxhc3RJbmRleDtcbiAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gIGxldCBjdXJyZW50VmFsdWU7XG4gIGxldCBuZXh0VmFsdWU7XG5cbiAgd2hpbGUgKGxvd2VySW5kZXggPD0gdXBwZXJJbmRleCkge1xuICAgIGN1cnJlbnRJbmRleCA9IE1hdGguZmxvb3IoKGxvd2VySW5kZXggKyB1cHBlckluZGV4KSAvIDIpO1xuICAgIGN1cnJlbnRWYWx1ZSA9IHN0b3BzW2N1cnJlbnRJbmRleF07XG4gICAgbmV4dFZhbHVlID0gc3RvcHNbY3VycmVudEluZGV4ICsgMV07XG5cbiAgICBpZiAoY3VycmVudFZhbHVlIDw9IGlucHV0KSB7XG4gICAgICBpZiAoY3VycmVudEluZGV4ID09PSBsYXN0SW5kZXggfHwgaW5wdXQgPCBuZXh0VmFsdWUpIHtcbiAgICAgICAgLy8gU2VhcmNoIGNvbXBsZXRlXG4gICAgICAgIHJldHVybiBjdXJyZW50SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGxvd2VySW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gaW5wdXQpIHtcbiAgICAgIHVwcGVySW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlzIG5vdCBhIG51bWJlci4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZwNjRMb3dQYXJ0KHg6IG51bWJlcikge1xuICByZXR1cm4geCAtIE1hdGguZnJvdW5kKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF0NEludmVydChvdXQ6IG51bWJlcltdLCBhOiBudW1iZXJbXSkge1xuICBjb25zdCBhMDAgPSBhWzBdO1xuICBjb25zdCBhMDEgPSBhWzFdO1xuICBjb25zdCBhMDIgPSBhWzJdO1xuICBjb25zdCBhMDMgPSBhWzNdO1xuICBjb25zdCBhMTAgPSBhWzRdO1xuICBjb25zdCBhMTEgPSBhWzVdO1xuICBjb25zdCBhMTIgPSBhWzZdO1xuICBjb25zdCBhMTMgPSBhWzddO1xuICBjb25zdCBhMjAgPSBhWzhdO1xuICBjb25zdCBhMjEgPSBhWzldO1xuICBjb25zdCBhMjIgPSBhWzEwXTtcbiAgY29uc3QgYTIzID0gYVsxMV07XG4gIGNvbnN0IGEzMCA9IGFbMTJdO1xuICBjb25zdCBhMzEgPSBhWzEzXTtcbiAgY29uc3QgYTMyID0gYVsxNF07XG4gIGNvbnN0IGEzMyA9IGFbMTVdO1xuXG4gIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICBjb25zdCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICBjb25zdCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICBjb25zdCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICBjb25zdCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICBsZXQgZGV0ID1cbiAgICBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0OiBudW1iZXJbXSwgYTogbnVtYmVyW10sIG06IG51bWJlcltdKSB7XG4gIGNvbnN0IHggPSBhWzBdO1xuICBjb25zdCB5ID0gYVsxXTtcbiAgY29uc3QgeiA9IGFbMl07XG4gIGNvbnN0IHcgPSBhWzNdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7IC8vIDBcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3OyAvLyAwXG4gIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7IC8vIDBcbiAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdzsgLy8gMVxuICByZXR1cm4gb3V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXllKG1hdHJpeDogbnVtYmVyW10pIHtcbiAgY29uc3QgZGVmYXVsdE1hdDQgPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07IC8vIGluc3RlZCBvZiBtYXQ0LmNyZWF0ZSgpXG4gIGxldCBleWUgPSB0cmFuc2Zvcm1NYXQ0KFxuICAgIFtdLFxuICAgIFswLCAwLCAwLCAxXSxcbiAgICBtYXQ0SW52ZXJ0KGRlZmF1bHRNYXQ0LCBtYXRyaXgpIGFzIG51bWJlcltdLFxuICApO1xuICBjb25zdCBjbGlwVyA9IDEuMCAvIGV5ZVszXTtcbiAgZXllID0gZXllLm1hcCgoaXRlbTogbnVtYmVyKSA9PiBpdGVtIC8gZXllWzNdKTtcbiAgZXllWzNdID0gY2xpcFc7XG4gIHJldHVybiBleWU7XG59XG4iLCJpbXBvcnQgeyBjYWxjTWluTWF4IH0gZnJvbSAnLi4vdXRpbHMvY29tbW9uJztcblxuY29uc3QgY3R4OiBXb3JrZXIgPSBzZWxmIGFzIGFueTtcblxuY3R4LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoeyBkYXRhOiBwYXlsb2FkIH0pID0+IHtcbiAgY29uc3QgcmVuZGVyRm9ybSA9IHBheWxvYWRbMF07XG4gIGlmIChyZW5kZXJGb3JtID09PSAncmcnKSB7XG4gICAgY29uc3QgdURhdGEgPSBwYXlsb2FkWzFdO1xuICAgIGNvbnN0IHZEYXRhID0gcGF5bG9hZFsyXTtcbiAgICBjb25zdCBbdU1pbiwgdU1heF0gPSBjYWxjTWluTWF4KHVEYXRhKTtcbiAgICBjb25zdCBbdk1pbiwgdk1heF0gPSBjYWxjTWluTWF4KHZEYXRhKTtcbiAgICBjb25zdCB2ZWxvY2l0eURhdGEgPSBuZXcgVWludDhBcnJheSh1RGF0YS5sZW5ndGggKiA0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByID0gMjU1ICogKHVEYXRhW2ldIC0gdU1pbikgLyAodU1heCAtIHVNaW4pO1xuICAgICAgY29uc3QgZyA9IDI1NSAqICh2RGF0YVtpXSAtIHZNaW4pIC8gKHZNYXggLSB2TWluKTtcbiAgICAgIHZlbG9jaXR5RGF0YS5zZXQoW3IsIGcsIDAsIDI1NV0sIGkgKiA0KTtcbiAgICB9XG5cbiAgICBjdHgucG9zdE1lc3NhZ2UoW3ZlbG9jaXR5RGF0YS5idWZmZXIsIHVNaW4sIHVNYXgsIHZNaW4sIHZNYXhdLCBbdmVsb2NpdHlEYXRhLmJ1ZmZlcl0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNpbmdsZURhdGEgPSBwYXlsb2FkWzFdO1xuICAgIGNvbnN0IFttaW4sIG1heF0gPSBjYWxjTWluTWF4KHNpbmdsZURhdGEpO1xuICAgIGNvbnN0IHZlbG9jaXR5RGF0YSA9IG5ldyBVaW50OEFycmF5KHNpbmdsZURhdGEubGVuZ3RoICogNCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaW5nbGVEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByID0gMjU1ICogKHNpbmdsZURhdGFbaV0gLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gICAgICB2ZWxvY2l0eURhdGEuc2V0KFtyLCAwLCAwLCAyNTVdLCBpICogNCk7XG4gICAgfVxuXG4gICAgY3R4LnBvc3RNZXNzYWdlKFt2ZWxvY2l0eURhdGEuYnVmZmVyLCBtaW4sIG1heF0sIFt2ZWxvY2l0eURhdGEuYnVmZmVyXSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztFQUFPLFNBQVMsV0FBVyxLQUFtQyxFQUFBO0VBQzVELEVBQUEsSUFBSSxHQUFNLEdBQUEsUUFBQSxDQUFBO0VBQ1YsRUFBQSxJQUFJLEdBQU0sR0FBQSxRQUFBLENBQUE7RUFFVixFQUFBLEtBQUEsSUFBUyxDQUFJLEdBQUEsQ0FBQSxFQUFHLENBQUksR0FBQSxLQUFBLENBQU0sUUFBUSxDQUFLLEVBQUEsRUFBQTtFQUNyQyxJQUFBLE1BQU0sTUFBTSxLQUFNLENBQUEsQ0FBQSxDQUFBLENBQUE7RUFFbEIsSUFBQSxJQUFJLFFBQVEsUUFBVSxFQUFBO0VBQ3BCLE1BQU0sR0FBQSxHQUFBLEdBQUEsQ0FBQTtFQUFBLEtBQ1IsTUFBQSxJQUFXLFFBQVEsUUFBVSxFQUFBO0VBQzNCLE1BQU0sR0FBQSxHQUFBLEdBQUEsQ0FBQTtFQUdOLE1BQU0sR0FBQSxHQUFBLElBQUEsQ0FBSyxHQUFJLENBQUEsR0FBQSxFQUFLLEdBQUcsQ0FBQSxDQUFBO0VBQ3ZCLE1BQU0sR0FBQSxHQUFBLElBQUEsQ0FBSyxHQUFJLENBQUEsR0FBQSxFQUFLLEdBQUcsQ0FBQSxDQUFBO0VBQUEsS0FDbEIsTUFBQTtFQUdMLE1BQU0sR0FBQSxHQUFBLElBQUEsQ0FBSyxHQUFJLENBQUEsR0FBQSxFQUFLLEdBQUcsQ0FBQSxDQUFBO0VBQ3ZCLE1BQU0sR0FBQSxHQUFBLElBQUEsQ0FBSyxHQUFJLENBQUEsR0FBQSxFQUFLLEdBQUcsQ0FBQSxDQUFBO0VBQUEsS0FDekI7RUFBQSxHQUNGO0VBQ0EsRUFBTyxPQUFBLENBQUMsS0FBSyxHQUFHLENBQUEsQ0FBQTtFQUNsQjs7RUNyQkEsTUFBTSxHQUFjLEdBQUEsSUFBQSxDQUFBO0VBRXBCLEdBQUEsQ0FBSSxpQkFBaUIsU0FBVyxFQUFBLE9BQU8sRUFBRSxJQUFBLEVBQU0sU0FBYyxLQUFBO0VBQzNELEVBQUEsTUFBTSxhQUFhLE9BQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtFQUMzQixFQUFBLElBQUksZUFBZSxJQUFNLEVBQUE7RUFDdkIsSUFBQSxNQUFNLFFBQVEsT0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBO0VBQ3RCLElBQUEsTUFBTSxRQUFRLE9BQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtFQUN0QixJQUFBLE1BQU0sQ0FBQyxJQUFBLEVBQU0sSUFBSSxDQUFBLEdBQUksV0FBVyxLQUFLLENBQUEsQ0FBQTtFQUNyQyxJQUFBLE1BQU0sQ0FBQyxJQUFBLEVBQU0sSUFBSSxDQUFBLEdBQUksV0FBVyxLQUFLLENBQUEsQ0FBQTtFQUNyQyxJQUFBLE1BQU0sWUFBZSxHQUFBLElBQUksVUFBVyxDQUFBLEtBQUEsQ0FBTSxTQUFTLENBQUMsQ0FBQSxDQUFBO0VBQ3BELElBQUEsS0FBQSxJQUFTLENBQUksR0FBQSxDQUFBLEVBQUcsQ0FBSSxHQUFBLEtBQUEsQ0FBTSxRQUFRLENBQUssRUFBQSxFQUFBO0VBQ3JDLE1BQUEsTUFBTSxDQUFJLEdBQUEsR0FBQSxJQUFPLEtBQU0sQ0FBQSxDQUFBLENBQUEsR0FBSyxTQUFTLElBQU8sR0FBQSxJQUFBLENBQUEsQ0FBQTtFQUM1QyxNQUFBLE1BQU0sQ0FBSSxHQUFBLEdBQUEsSUFBTyxLQUFNLENBQUEsQ0FBQSxDQUFBLEdBQUssU0FBUyxJQUFPLEdBQUEsSUFBQSxDQUFBLENBQUE7RUFDNUMsTUFBYSxZQUFBLENBQUEsR0FBQSxDQUFJLENBQUMsQ0FBRyxFQUFBLENBQUEsRUFBRyxHQUFHLEdBQUcsQ0FBQSxFQUFHLElBQUksQ0FBQyxDQUFBLENBQUE7RUFBQSxLQUN4QztFQUVBLElBQUEsR0FBQSxDQUFJLFdBQVksQ0FBQSxDQUFDLFlBQWEsQ0FBQSxNQUFBLEVBQVEsSUFBTSxFQUFBLElBQUEsRUFBTSxJQUFNLEVBQUEsSUFBSSxDQUFHLEVBQUEsQ0FBQyxZQUFhLENBQUEsTUFBTSxDQUFDLENBQUEsQ0FBQTtFQUFBLEdBQy9FLE1BQUE7RUFDTCxJQUFBLE1BQU0sYUFBYSxPQUFRLENBQUEsQ0FBQSxDQUFBLENBQUE7RUFDM0IsSUFBQSxNQUFNLENBQUMsR0FBQSxFQUFLLEdBQUcsQ0FBQSxHQUFJLFdBQVcsVUFBVSxDQUFBLENBQUE7RUFDeEMsSUFBQSxNQUFNLFlBQWUsR0FBQSxJQUFJLFVBQVcsQ0FBQSxVQUFBLENBQVcsU0FBUyxDQUFDLENBQUEsQ0FBQTtFQUN6RCxJQUFBLEtBQUEsSUFBUyxDQUFJLEdBQUEsQ0FBQSxFQUFHLENBQUksR0FBQSxVQUFBLENBQVcsUUFBUSxDQUFLLEVBQUEsRUFBQTtFQUMxQyxNQUFBLE1BQU0sQ0FBSSxHQUFBLEdBQUEsSUFBTyxVQUFXLENBQUEsQ0FBQSxDQUFBLEdBQUssUUFBUSxHQUFNLEdBQUEsR0FBQSxDQUFBLENBQUE7RUFDL0MsTUFBYSxZQUFBLENBQUEsR0FBQSxDQUFJLENBQUMsQ0FBRyxFQUFBLENBQUEsRUFBRyxHQUFHLEdBQUcsQ0FBQSxFQUFHLElBQUksQ0FBQyxDQUFBLENBQUE7RUFBQSxLQUN4QztFQUVBLElBQUksR0FBQSxDQUFBLFdBQUEsQ0FBWSxDQUFDLFlBQUEsQ0FBYSxNQUFRLEVBQUEsR0FBQSxFQUFLLEdBQUcsQ0FBRyxFQUFBLENBQUMsWUFBYSxDQUFBLE1BQU0sQ0FBQyxDQUFBLENBQUE7RUFBQSxHQUN4RTtFQUNGLENBQUMsQ0FBQTs7Ozs7OyJ9', false);
    /* eslint-enable */

    function calcMinMax(array) {
      let min = Infinity;
      let max = Infinity;
      for (let i = 0; i < array.length; i++) {
        const val = array[i];
        if (min === Infinity) {
          min = val;
        } else if (max === Infinity) {
          max = val;
          min = Math.min(min, max);
          max = Math.max(min, max);
        } else {
          min = Math.min(val, min);
          max = Math.max(val, max);
        }
      }
      return [min, max];
    }
    function isNumber(val) {
      return typeof val === "number" && !isNaN(val);
    }
    function isValide(val) {
      return val !== void 0 && val !== null && !isNaN(val);
    }
    function findStopLessThanOrEqualTo(stops, input) {
      const lastIndex = stops.length - 1;
      let lowerIndex = 0;
      let upperIndex = lastIndex;
      let currentIndex = 0;
      let currentValue;
      let nextValue;
      while (lowerIndex <= upperIndex) {
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex];
        nextValue = stops[currentIndex + 1];
        if (currentValue <= input) {
          if (currentIndex === lastIndex || input < nextValue) {
            return currentIndex;
          }
          lowerIndex = currentIndex + 1;
        } else if (currentValue > input) {
          upperIndex = currentIndex - 1;
        } else {
          throw new Error("Input is not a number.");
        }
      }
      return 0;
    }
    function fp64LowPart(x) {
      return x - Math.fround(x);
    }
    function mat4Invert(out, a) {
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a10 = a[4];
      const a11 = a[5];
      const a12 = a[6];
      const a13 = a[7];
      const a20 = a[8];
      const a21 = a[9];
      const a22 = a[10];
      const a23 = a[11];
      const a30 = a[12];
      const a31 = a[13];
      const a32 = a[14];
      const a33 = a[15];
      const b00 = a00 * a11 - a01 * a10;
      const b01 = a00 * a12 - a02 * a10;
      const b02 = a00 * a13 - a03 * a10;
      const b03 = a01 * a12 - a02 * a11;
      const b04 = a01 * a13 - a03 * a11;
      const b05 = a02 * a13 - a03 * a12;
      const b06 = a20 * a31 - a21 * a30;
      const b07 = a20 * a32 - a22 * a30;
      const b08 = a20 * a33 - a23 * a30;
      const b09 = a21 * a32 - a22 * a31;
      const b10 = a21 * a33 - a23 * a31;
      const b11 = a22 * a33 - a23 * a32;
      let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) {
        return null;
      }
      det = 1 / det;
      out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
      out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
      out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
      out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
      out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    }
    function transformMat4(out, a, m) {
      const x = a[0];
      const y = a[1];
      const z = a[2];
      const w = a[3];
      out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
      out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
      out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
      out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
      return out;
    }
    function getEye(matrix) {
      const defaultMat4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      let eye = transformMat4(
        [],
        [0, 0, 0, 1],
        mat4Invert(defaultMat4, matrix)
      );
      const clipW = 1 / eye[3];
      eye = eye.map((item) => item / eye[3]);
      eye[3] = clipW;
      return eye;
    }

    function getDevicePixelRatio() {
      return devicePixelRatio || 1;
    }
    function resizeCanvasSize(canvas, pixelRatio) {
      if (!canvas) {
        return false;
      }
      pixelRatio = pixelRatio || getDevicePixelRatio();
      if (canvas instanceof HTMLCanvasElement) {
        const width = canvas.clientWidth * pixelRatio;
        const height = canvas.clientHeight * pixelRatio;
        if (width <= 0 || height <= 0) {
          return false;
        } else if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
          return true;
        }
      }
      return false;
    }
    function getGlContext(canvas, glOptions = {}) {
      const names = ["webgl", "experimental-webgl"];
      let context = null;
      function onContextCreationError(error) {
        console.error(error.statusMessage);
      }
      canvas.addEventListener(
        "webglcontextcreationerror",
        onContextCreationError,
        false
      );
      for (let ii = 0; ii < names.length; ++ii) {
        try {
          context = canvas.getContext(
            names[ii],
            glOptions
          );
        } catch (e) {
        }
        if (context) {
          break;
        }
      }
      canvas.removeEventListener(
        "webglcontextcreationerror",
        onContextCreationError,
        false
      );
      if (!context || !context.getExtension("OES_texture_float")) {
        return null;
      }
      return context;
    }
    function defineShader(shader, defines) {
      return Object.keys(defines).reduce((str, key) => {
        return defines[key] ? str + `#define ${key} ${defines[key]}
` : "";
      }, "");
    }
    function injectShaderModule(shader, modules = {}) {
      Object.keys(modules).map((key) => {
        if (modules[key]) {
          shader = shader.replace(new RegExp(key, "g"), `${modules[key]} 
`);
        }
      });
      return shader;
    }
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const log = gl.getShaderInfoLog(shader) || "";
        gl.deleteShader(shader);
        throw new Error(log);
      }
      return shader;
    }
    function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(
        gl,
        gl.FRAGMENT_SHADER,
        fragmentShaderSource
      );
      const program = gl.createProgram();
      if (program !== null) {
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          throw new Error(gl.getProgramInfoLog(program) || "");
        }
      }
      return program;
    }
    function createTexture(gl, filter, data, width, height) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
      if (data instanceof Uint8Array) {
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          width,
          height,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          data
        );
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
      gl.bindTexture(gl.TEXTURE_2D, null);
      return texture;
    }
    function resizeTexture(gl, texture, width, height, data) {
      gl.bindTexture(gl.TEXTURE_2D, texture);
      if (data instanceof Uint8Array) {
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          width,
          height,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          data
        );
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    function bindTexture(gl, texture, unit) {
      gl.activeTexture(gl.TEXTURE0 + unit);
      gl.bindTexture(gl.TEXTURE_2D, texture);
    }
    function destroyTexture(gl, texture) {
      gl.deleteTexture(texture);
    }
    function createBuffer(gl, data) {
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      if (data) {
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
      }
      return buffer;
    }
    function updateBufferData(gl, buffer, data) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      if (data) {
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
      }
      return buffer;
    }
    function bindAttribute(gl, buffer, attribute, numComponents) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.enableVertexAttribArray(attribute);
      gl.vertexAttribPointer(attribute, numComponents, gl.FLOAT, false, 0, 0);
    }
    function bindFramebuffer(gl, framebuffer, texture) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      if (texture) {
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          texture,
          0
        );
      }
    }
    function resizeFramebuffer(gl, framebuffer, width, height, texture) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      if (texture) {
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          texture,
          0
        );
      }
    }
    function clearScene(gl, color, depth = 1, stencil = 0, fbo) {
      const [r, g, b, a] = color;
      let clearFlags = 0;
      gl.clearColor(r, g, b, a);
      clearFlags |= gl.COLOR_BUFFER_BIT;
      if (depth !== void 0) {
        gl.clearDepth(depth);
        clearFlags |= gl.DEPTH_BUFFER_BIT;
      }
      if (stencil !== void 0) {
        gl.clearStencil(stencil | 0);
        clearFlags |= gl.STENCIL_BUFFER_BIT;
      }
      gl.clear(clearFlags);
    }
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        if (!src) {
          reject(new Event("url is null"));
        }
        const image = new Image();
        image.crossOrigin = "anonymous";
        image.onload = () => resolve(image);
        image.onerror = reject;
        image.src = src;
        if (image.complete) {
          resolve(image);
        }
      });
    }
    function getPlaneBuffer(startX, endX, startY, endY, widthSegments, heightSegments) {
      const width = endX - startX;
      const height = endY - startY;
      const widthHalf = width / 2;
      const heightHalf = height / 2;
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const segmentWidth = width / gridX;
      const segmentHeight = height / gridY;
      const indices = [];
      const wireframeIndexes = [];
      const vertices = [];
      const verticesLow = [];
      const uvs = [];
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth;
          const vx = startX + x / widthHalf / 2 * width;
          const vy = startY + y / heightHalf / 2 * height;
          vertices.push(vx, vy, 0);
          verticesLow.push(fp64LowPart(vx), fp64LowPart(vy), 0);
          uvs.push(ix / gridX, iy / gridY);
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = ix + gridX1 * iy;
          const b = ix + gridX1 * (iy + 1);
          const c = ix + 1 + gridX1 * (iy + 1);
          const d = ix + 1 + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      for (let i = 0, l = indices.length; i < l; i += 3) {
        const a = indices[i];
        const b = indices[i + 1];
        const c = indices[i + 2];
        wireframeIndexes.push(a, b, b, c, c, a);
      }
      return {
        uvs: {
          data: uvs,
          size: 2
        },
        elements: {
          data: indices,
          count: indices.length
        },
        wireframeElements: {
          data: wireframeIndexes,
          count: wireframeIndexes.length
        },
        position: {
          data: vertices,
          size: 3
        },
        positionLow: {
          data: verticesLow,
          size: 3
        }
      };
    }

    class Base {
      constructor(gl, vShader, fShader, modules) {
        this.vertShader = "";
        this.fragShader = "";
        if (vShader) {
          this.vertShader = vShader;
        }
        if (fShader) {
          this.fragShader = fShader;
        }
        this.program = createProgram(
          gl,
          injectShaderModule(this.vertShader, modules),
          this.fragShader
        );
        this.gl = gl;
        this.textureUnit = 0;
        this.uniformSetters = this.createUniformSetters();
        this.attribSetters = this.createAttributeSetters();
        this.transfromStack = [];
      }
      active() {
        this.gl.useProgram(this.program);
        return this;
      }
      deactive() {
        this.gl.deleteProgram(this.program);
        return this;
      }
      getBindPointForSamplerType(gl, type) {
        if (type === gl.SAMPLER_2D) {
          return gl.TEXTURE_2D;
        }
        if (type === gl.SAMPLER_CUBE) {
          return gl.TEXTURE_CUBE_MAP;
        }
        return void 0;
      }
      createUniformSetter(program, uniformInfo) {
        const { gl } = this;
        const location = gl.getUniformLocation(program, uniformInfo.name);
        const type = uniformInfo.type;
        const isArray = uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]";
        if (type === gl.FLOAT && isArray) {
          return function(v) {
            gl.uniform1fv(location, v);
          };
        }
        if (type === gl.FLOAT) {
          return function(v) {
            gl.uniform1f(location, v);
          };
        }
        if (type === gl.FLOAT_VEC2) {
          return function(v) {
            gl.uniform2fv(location, v);
          };
        }
        if (type === gl.FLOAT_VEC3) {
          return function(v) {
            gl.uniform3fv(location, v);
          };
        }
        if (type === gl.FLOAT_VEC4) {
          return function(v) {
            gl.uniform4fv(location, v);
          };
        }
        if (type === gl.INT && isArray) {
          return function(v) {
            gl.uniform1iv(location, v);
          };
        }
        if (type === gl.INT) {
          return function(v) {
            gl.uniform1i(location, v);
          };
        }
        if (type === gl.INT_VEC2) {
          return function(v) {
            gl.uniform2iv(location, v);
          };
        }
        if (type === gl.INT_VEC3) {
          return function(v) {
            gl.uniform3iv(location, v);
          };
        }
        if (type === gl.INT_VEC4) {
          return function(v) {
            gl.uniform4iv(location, v);
          };
        }
        if (type === gl.BOOL) {
          return function(v) {
            gl.uniform1iv(location, v);
          };
        }
        if (type === gl.BOOL_VEC2) {
          return function(v) {
            gl.uniform2iv(location, v);
          };
        }
        if (type === gl.BOOL_VEC3) {
          return function(v) {
            gl.uniform3iv(location, v);
          };
        }
        if (type === gl.BOOL_VEC4) {
          return function(v) {
            gl.uniform4iv(location, v);
          };
        }
        if (type === gl.FLOAT_MAT2) {
          return function(v) {
            gl.uniformMatrix2fv(location, false, v);
          };
        }
        if (type === gl.FLOAT_MAT3) {
          return function(v) {
            gl.uniformMatrix3fv(location, false, v);
          };
        }
        if (type === gl.FLOAT_MAT4) {
          return function(v) {
            gl.uniformMatrix4fv(location, false, v);
          };
        }
        if ((type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) && isArray) {
          const units = [];
          for (let ii = 0; ii < uniformInfo.size; ++ii) {
            units.push(this.textureUnit++);
          }
          return function(bindPoint, units2) {
            return function(textures) {
              gl.uniform1iv(location, units2);
              textures.forEach(function(texture, index) {
                gl.activeTexture(gl.TEXTURE0 + units2[index]);
                if (bindPoint !== void 0) {
                  gl.bindTexture(bindPoint, texture);
                }
              });
            };
          }(this.getBindPointForSamplerType(gl, type), units);
        }
        if (type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) {
          return function(bindPoint, unit) {
            return function(texture) {
              gl.uniform1i(location, unit);
              gl.activeTexture(gl.TEXTURE0 + unit);
              if (bindPoint !== void 0) {
                gl.bindTexture(bindPoint, texture);
              }
            };
          }(this.getBindPointForSamplerType(gl, type), this.textureUnit++);
        }
        throw new Error("unknown type: 0x" + type.toString(16));
      }
      createUniformSetters() {
        const { gl } = this;
        this.textureUnit = 0;
        const uniformSetters = {};
        if (this.program !== null) {
          const numUniforms = gl.getProgramParameter(
            this.program,
            gl.ACTIVE_UNIFORMS
          );
          for (let ii = 0; ii < numUniforms; ++ii) {
            const uniformInfo = gl.getActiveUniform(
              this.program,
              ii
            );
            if (!uniformInfo) {
              break;
            }
            let name = uniformInfo.name;
            if (name.substr(-3) === "[0]") {
              name = name.substr(0, name.length - 3);
            }
            const setter = this.createUniformSetter(this.program, uniformInfo);
            uniformSetters[name] = setter;
          }
        }
        return uniformSetters;
      }
      createAttribSetter(index) {
        const { gl } = this;
        return function(b) {
          gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
          gl.enableVertexAttribArray(index);
          if (b.numComponents !== void 0 || b.size !== void 0) {
            gl.vertexAttribPointer(
              index,
              b.numComponents || b.size,
              b.type || gl.FLOAT,
              b.normalize || false,
              b.stride || 0,
              b.offset || 0
            );
          }
        };
      }
      createAttributeSetters() {
        const { gl } = this;
        const attribSetters = {};
        if (this.program !== null) {
          const numAttribs = gl.getProgramParameter(
            this.program,
            gl.ACTIVE_ATTRIBUTES
          );
          for (let ii = 0; ii < numAttribs; ++ii) {
            const attribInfo = gl.getActiveAttrib(
              this.program,
              ii
            );
            if (!attribInfo) {
              break;
            }
            const index = gl.getAttribLocation(this.program, attribInfo.name);
            attribSetters[attribInfo.name] = this.createAttribSetter(index);
          }
        }
        return attribSetters;
      }
      setAttributes(attribs, setters) {
        if (setters) {
          setters = setters.attribSetters || setters;
        } else {
          setters = this.attribSetters;
        }
        Object.keys(attribs).forEach(function(name) {
          const setter = setters[name];
          if (setter) {
            setter(attribs[name]);
          }
        });
        return this;
      }
      setUniforms(values, setters) {
        if (setters) {
          setters = setters.uniformSetters || setters;
        } else {
          setters = this.uniformSetters;
        }
        Object.keys(values).forEach(function(name) {
          const setter = setters[name];
          if (setter) {
            setter(values[name]);
          }
        });
        return this;
      }
      elements(element) {
        if (!this.elementsBuffer) {
          this.elementsBuffer = this.gl.createBuffer();
        }
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.elementsBuffer);
        if (element.data) {
          this.gl.bufferData(
            this.gl.ELEMENT_ARRAY_BUFFER,
            element.data,
            element.usage || this.gl.STATIC_DRAW
          );
        }
        if (element.count !== void 0) {
          this.runTimes(element.count);
        }
        if (element.primitive) {
          this.setPrimitive(element.primitive);
        }
        return this;
      }
      clear(color) {
        clearScene(this.gl, color);
        this.transfromStack = [];
        return this;
      }
      runTimes(count) {
        this.count = count || 0;
        return this;
      }
      setPrimitive(primitive) {
        this.primitive = primitive || this.gl.TRIANGLES;
        return this;
      }
      resize(width, height) {
        if (width === void 0 || height === void 0) {
          resizeCanvasSize(this.gl.canvas);
          this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
        } else {
          this.gl.viewport(0, 0, width, height);
        }
        return this;
      }
      draw() {
        throw new Error("should override");
      }
      translate() {
        throw new Error("should override");
      }
      rotate() {
        throw new Error("should override");
      }
      scale() {
        throw new Error("should override");
      }
      destroyed() {
        throw new Error("should override");
      }
    }

    var FillFrag$1 = "precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform vec2 u_image_res;uniform vec2 u_range;uniform vec2 u_color_range;uniform vec2 u_display_range;uniform float u_opacity;varying vec2 v_tex_pos;float calcTexture(const vec2 uv){return texture2D(u_image,uv).r;}float bilinear(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);float tl=calcTexture(vc);float tr=calcTexture(vc+vec2(px.x,0));float bl=calcTexture(vc+vec2(0,px.y));float br=calcTexture(vc+px);return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}float getValue(const vec2 uv){float min=u_range.x;float max=u_range.y;float r=bilinear(uv);return r*(max-min)+min;}const float PI=3.14159265359;vec2 mercatorToWGS84(vec2 xy){float y=radians(180.0-xy.y*360.0);y=360.0/PI*atan(exp(y))-90.0;y=y/-180.0+0.5;return vec2(xy.x,y);}void main(){vec2 globalWGS84=mercatorToWGS84(v_tex_pos);float value=getValue(globalWGS84);float value_t=(value-u_color_range.x)/(u_color_range.y-u_color_range.x);vec2 ramp_pos=vec2(fract(16.0*value_t),floor(16.0*value_t)/16.0);vec4 color=texture2D(u_color_ramp,ramp_pos);bool display=value<u_display_range.y&&value>u_display_range.x;if(display){gl_FragColor=vec4(floor(255.0*color*u_opacity)/255.0);}else{gl_FragColor=vec4(0.0,0.0,0.0,0.0);}}"; // eslint-disable-line

    var FillVert$1 = "#define GLSLIFY 1\nattribute vec3 instancePositions;attribute vec3 instancePositions64Low;attribute vec2 a_texCoord;uniform mat4 u_matrix;uniform vec4 u_cameraEye;uniform vec4 u_cameraEye64Low;uniform float u_offset;uniform sampler2D u_image;uniform vec2 u_image_res;uniform vec2 u_range;uniform vec2 u_mapping_range;varying vec2 v_tex_pos;varying float v_value;float calcTexture(const vec2 uv){return texture2D(u_image,uv).r;}float bilinear(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);float tl=calcTexture(vc);float tr=calcTexture(vc+vec2(px.x,0));float bl=calcTexture(vc+vec2(0,px.y));float br=calcTexture(vc+px);return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}float getValue(const vec2 uv){float min=u_mapping_range.x;float max=u_mapping_range.y;float r=bilinear(uv);return r*(max-min)+min;}const float PI=3.14159265359;vec2 mercatorToWGS84(vec2 xy){float y=radians(180.0-xy.y*360.0);y=360.0/PI*atan(exp(y))-90.0;y=y/-180.0+0.5;return vec2(xy.x,y);}\n#modules-transformZ\nvoid main(){v_tex_pos=a_texCoord;vec2 globalWGS84=mercatorToWGS84(v_tex_pos);float value=getValue(globalWGS84);float z=transformZ(value,instancePositions);vec4 pos=vec4(instancePositions-u_cameraEye.xyz,0.0);pos+=vec4(instancePositions64Low-u_cameraEye64Low.xyz,0.0);\n#modules-project\n}"; // eslint-disable-line

    class Fill extends Base {
      constructor(gl, vShader, fShader, modules) {
        super(gl, vShader || FillVert$1, fShader || FillFrag$1, modules || {});
        this.vertShader = FillVert$1;
        this.fragShader = FillFrag$1;
      }
      draw() {
        if (this.checkExt !== void 0) {
          const primitiveType = this.primitive || this.gl.TRIANGLES;
          if (this.checkExt) {
            this.gl.drawElements(
              primitiveType,
              this.count,
              this.gl.UNSIGNED_INT,
              0
            );
          } else {
            this.gl.drawElements(
              primitiveType,
              this.count,
              this.gl.UNSIGNED_SHORT,
              0
            );
          }
        } else {
          this.checkExt = this.gl.getExtension("OES_element_index_uint");
        }
        return this;
      }
      translate() {
        return this;
      }
      rotate() {
        return this;
      }
      scale() {
        return this;
      }
    }

    function parseColorStyle(styleAttrField) {
      if (Array.isArray(styleAttrField) && styleAttrField.length > 3) {
        const type = styleAttrField[0];
        const action = styleAttrField[1];
        const interpolateColor = [];
        for (let i = 3; i < styleAttrField.length; i += 2) {
          const val = styleAttrField[i];
          const color = styleAttrField[i + 1];
          interpolateColor.push({
            key: val,
            value: color
          });
        }
        return {
          operator: type,
          interpolation: {
            name: action[0],
            base: action[1]
          },
          input: interpolateColor
        };
      } else {
        console.warn("[wind-core]: style-parser style config invalid");
        return {};
      }
    }
    function parseZoomStyle(styleAttrField) {
      if (Array.isArray(styleAttrField) && styleAttrField.length > 3) {
        const type = styleAttrField[0];
        const action = styleAttrField[1];
        const interpolateZoom = [];
        for (let i = 3; i < styleAttrField.length; i += 2) {
          const val = styleAttrField[i];
          const color = styleAttrField[i + 1];
          interpolateZoom.push({
            key: val,
            value: color
          });
        }
        return {
          operator: type,
          interpolation: {
            name: action[0],
            base: action[1]
          },
          input: interpolateZoom
        };
      } else {
        console.warn("[wind-core]: style-parser style config invalid");
        return {};
      }
    }
    function createLinearGradient(range, styleAttrField) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = 256;
      canvas.height = 1;
      const { input: interpolateColor } = parseColorStyle(styleAttrField);
      if (ctx && interpolateColor && Array.isArray(interpolateColor)) {
        const keys = interpolateColor.map((d) => parseFloat(d.key));
        const colorRange = [Math.min(...keys), Math.max(...keys)];
        const [min, max] = [range[0] || colorRange[0], range[1] || colorRange[1]];
        const gradient = ctx.createLinearGradient(0, 0, 256, 0);
        for (let i = 0; i < interpolateColor.length; i += 1) {
          const key = interpolateColor[i].key;
          const color = interpolateColor[i].value;
          gradient.addColorStop((key - min) / (max - min), color);
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 1);
        return {
          data: new Uint8Array(ctx.getImageData(0, 0, 256, 1).data),
          colorRange
        };
      } else {
        return {};
      }
    }
    function exponentialInterpolation(input, base, lowerValue, upperValue) {
      const difference = upperValue - lowerValue;
      const progress = input - lowerValue;
      if (difference === 0) {
        return 0;
      } else if (base === 1) {
        return progress / difference;
      } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
      }
    }
    function interpolationFactor(interpolation, input, lower, upper) {
      let t = 0;
      if (interpolation.name === "exponential") {
        t = exponentialInterpolation(input, interpolation.base, lower, upper);
      } else if (interpolation.name === "linear") {
        t = exponentialInterpolation(input, 1, lower, upper);
      } else if (interpolation.name === "cubic-bezier") {
        console.warn("interpolationFactor");
      }
      return t;
    }
    function interpolateNumber(a, b, t) {
      return a * (1 - t) + b * t;
    }
    const cachedStyle = {};
    function createZoom(uid, zoom, key, styles, clearCache) {
      const ukey = `${uid}_${key}`;
      const styleAttrField = styles[key];
      if (isNumber(styleAttrField)) {
        if (cachedStyle[ukey]) {
          delete cachedStyle[ukey];
        }
        return styleAttrField;
      }
      if (styleAttrField && Array.isArray(styleAttrField) && (!cachedStyle[ukey] || clearCache)) {
        cachedStyle[ukey] = parseZoomStyle(styleAttrField);
      }
      if (cachedStyle[ukey]) {
        const { input: interpolateZoom, interpolation } = cachedStyle[ukey] || {};
        if (interpolateZoom && Array.isArray(interpolateZoom)) {
          const labels = interpolateZoom.map((i) => i.key);
          const outputs = interpolateZoom.map((i) => i.value);
          if (zoom <= labels[0]) {
            return outputs[0];
          }
          const stopCount = labels.length;
          if (zoom >= labels[stopCount - 1]) {
            return outputs[stopCount - 1];
          }
          const index = findStopLessThanOrEqualTo(labels, zoom);
          const idx = labels.length - 1;
          const lower = labels[index];
          const upper = labels[index >= idx ? idx : index + 1];
          const t = interpolationFactor(interpolation, zoom, lower, upper);
          const outputLower = outputs[index];
          const outputUpper = outputs[index >= idx ? idx : index + 1];
          return interpolateNumber(outputLower, outputUpper, t);
        } else {
          return 1;
        }
      }
      return 1;
    }

    var FillFrag = "precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_wind;uniform sampler2D u_color_ramp;uniform vec2 u_image_res;uniform vec2 u_wind_min;uniform vec2 u_wind_max;uniform vec2 u_color_range;uniform vec2 u_display_range;uniform float u_opacity;varying vec2 v_tex_pos;vec2 windTexture(const vec2 uv){return texture2D(u_wind,uv).rg;}float bilinearU(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);float tl=windTexture(vc).r;float tr=windTexture(vc+vec2(px.x,0)).r;float bl=windTexture(vc+vec2(0,px.y)).r;float br=windTexture(vc+px).r;return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}float bilinearV(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);float tl=windTexture(vc).g;float tr=windTexture(vc+vec2(px.x,0.0)).g;float bl=windTexture(vc+vec2(0.0,px.y)).g;float br=windTexture(vc+px).g;return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}float getV(const vec2 uv){float min=u_wind_min.y;float max=u_wind_max.y;float r=bilinearV(uv);return r*(max-min)+min;}float getU(const vec2 uv){float min=u_wind_min.x;float max=u_wind_max.x;float r=bilinearU(uv);return r*(max-min)+min;}float windSpeed(const vec2 uv){float u=getU(uv);float v=getV(uv);return length(vec2(u,v));}const float PI=3.14159265359;vec2 mercatorToWGS84(vec2 xy){float y=radians(180.0-xy.y*360.0);y=360.0/PI*atan(exp(y))-90.0;y=y/-180.0+0.5;return vec2(xy.x,y);}void main(){vec2 globalWGS84=mercatorToWGS84(v_tex_pos);float value=windSpeed(globalWGS84);float value_t=(value-u_color_range.x)/(u_color_range.y-u_color_range.x);vec2 ramp_pos=vec2(fract(16.0*value_t),floor(16.0*value_t)/16.0);vec4 color=texture2D(u_color_ramp,ramp_pos);bool display=value<u_display_range.y&&value>u_display_range.x;if(display){gl_FragColor=vec4(floor(255.0*color*u_opacity)/255.0);}else{gl_FragColor=vec4(0.0,0.0,0.0,0.0);}}"; // eslint-disable-line

    var FillVert = "#define GLSLIFY 1\nattribute vec3 instancePositions;attribute vec3 instancePositions64Low;attribute vec2 a_texCoord;uniform mat4 u_matrix;uniform vec4 u_cameraEye;uniform vec4 u_cameraEye64Low;uniform float u_offset;uniform sampler2D u_wind;uniform vec2 u_image_res;uniform vec2 u_wind_min;uniform vec2 u_wind_max;uniform vec2 u_mapping_range;varying vec2 v_tex_pos;varying float v_value;vec2 windTexture(const vec2 uv){return texture2D(u_wind,uv).rg;}float bilinearU(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);float tl=windTexture(vc).r;float tr=windTexture(vc+vec2(px.x,0)).r;float bl=windTexture(vc+vec2(0,px.y)).r;float br=windTexture(vc+px).r;return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}float bilinearV(const vec2 uv){vec2 px=1.0/u_image_res;vec2 vc=(floor(uv*u_image_res))*px;vec2 f=fract(uv*u_image_res);float tl=windTexture(vc).g;float tr=windTexture(vc+vec2(px.x,0.0)).g;float bl=windTexture(vc+vec2(0.0,px.y)).g;float br=windTexture(vc+px).g;return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}float getV(const vec2 uv){float min=u_wind_min.y;float max=u_wind_max.y;float r=bilinearV(uv);return r*(max-min)+min;}float getU(const vec2 uv){float min=u_wind_min.x;float max=u_wind_max.x;float r=bilinearU(uv);return r*(max-min)+min;}float windSpeed(const vec2 uv){float u=getU(uv);float v=getV(uv);float min=u_mapping_range.x;float max=u_mapping_range.y;float val=length(vec2(u,v));return val*(max-min)+min;}const float PI=3.14159265359;vec2 mercatorToWGS84(vec2 xy){float y=radians(180.0-xy.y*360.0);y=360.0/PI*atan(exp(y))-90.0;y=y/-180.0+0.5;return vec2(xy.x,y);}\n#modules-transformZ\nvoid main(){v_tex_pos=a_texCoord;vec2 globalWGS84=mercatorToWGS84(v_tex_pos);float value=windSpeed(globalWGS84);float z=transformZ(value,instancePositions);vec4 pos=vec4(instancePositions-u_cameraEye.xyz,0.0);pos+=vec4(instancePositions64Low-u_cameraEye64Low.xyz,0.0);\n#modules-project\n}"; // eslint-disable-line

    class WindFill extends Base {
      constructor(gl, vShader, fShader, modules) {
        super(gl, vShader || FillVert, fShader || FillFrag, modules || {});
        this.vertShader = FillVert;
        this.fragShader = FillFrag;
      }
      draw() {
        if (this.checkExt !== void 0) {
          const primitiveType = this.primitive || this.gl.TRIANGLES;
          if (this.checkExt) {
            this.gl.drawElements(
              primitiveType,
              this.count,
              this.gl.UNSIGNED_INT,
              0
            );
          } else {
            this.gl.drawElements(
              primitiveType,
              this.count,
              this.gl.UNSIGNED_SHORT,
              0
            );
          }
        } else {
          this.checkExt = this.gl.getExtension("OES_element_index_uint");
        }
        return this;
      }
      translate() {
        return this;
      }
      rotate() {
        return this;
      }
      scale() {
        return this;
      }
      destroyed() {
      }
    }

    const defaultOptions$2 = {
      renderForm: "r",
      styleSpec: {
        "fill-color": [
          "interpolate",
          ["linear"],
          ["get", "value"],
          0,
          "#3288bd",
          10,
          "#66c2a5",
          20,
          "#abdda4",
          30,
          "#e6f598",
          40,
          "#fee08b",
          50,
          "#fdae61",
          60,
          "#f46d43",
          100,
          "#d53e4f"
        ],
        opacity: 1
      },
      displayRange: [Infinity, Infinity],
      mappingRange: [0, 0],
      widthSegments: 1,
      heightSegments: 1,
      wireframe: false,
      createPlaneBuffer: (points, widthSegments, heightSegments) => {
        const [startX, endX, startY, endY] = [
          points[0][0],
          points[2][0],
          points[0][1],
          points[1][1]
        ];
        return getPlaneBuffer(
          startX,
          endX,
          startY,
          endY,
          widthSegments,
          heightSegments
        );
      },
      injectShaderModules: {
        "#modules-transformZ": `
float transformZ(float value, vec3 pos) {
  return 0.0;
}
    `,
        "#modules-project": `
gl_Position = u_matrix * vec4(pos.xy + vec2(u_offset, 0.0), pos.z + z, 1.0);
    `
      }
    };
    let uid$1 = 0;
    class ScalarFill {
      constructor(gl, options) {
        this.gl = gl;
        this.uid = `ScalarFill_${uid$1}`;
        uid$1++;
        if (!this.gl) {
          throw new Error("initialize error");
        }
        if (!options) {
          options = {};
        }
        this.options = {
          ...defaultOptions$2,
          ...options
        };
        this.opacity = this.options.opacity || 1;
      }
      updateOptions(options) {
        this.options = {
          ...this.options,
          ...options
        };
        this.buildColorRamp();
        if (typeof this.options.getZoom === "function") {
          this.setOpacity(
            createZoom(
              this.uid,
              this.options.getZoom(),
              "opacity",
              this.options.styleSpec,
              true
            )
          );
        }
      }
      setFillColor() {
        this.buildColorRamp();
      }
      setOpacity(opacity) {
        this.opacity = opacity;
      }
      handleZoom() {
        if (typeof this.options.getZoom === "function") {
          this.setOpacity(
            createZoom(
              this.uid,
              this.options.getZoom(),
              "opacity",
              this.options.styleSpec
            )
          );
        }
      }
      buildColorRamp() {
        var _a;
        const { data, colorRange } = createLinearGradient(
          [],
          (_a = this.options.styleSpec) == null ? void 0 : _a["fill-color"]
        );
        if (colorRange) {
          this.colorRange = colorRange;
        }
        if (data) {
          this.colorRampTexture = createTexture(
            this.gl,
            this.gl.NEAREST,
            data,
            16,
            16
          );
        }
      }
      initialize(gl) {
        if (!this.drawCommand) {
          if (this.options.renderForm === "rg") {
            this.drawCommand = new WindFill(
              gl,
              void 0,
              void 0,
              this.options.injectShaderModules
            );
          } else if (this.options.renderForm === "r") {
            this.drawCommand = new Fill(
              gl,
              void 0,
              void 0,
              this.options.injectShaderModules
            );
          } else {
            console.warn("This type is not supported temporarily");
          }
        }
        this.buildColorRamp();
        if (typeof this.options.getZoom === "function") {
          this.setOpacity(
            createZoom(
              this.uid,
              this.options.getZoom(),
              "opacity",
              this.options.styleSpec
            )
          );
        }
      }
      initializeVertex(coordinates) {
        let i = 0;
        const len = coordinates.length;
        const points = [];
        for (; i < len; i++) {
          const coords = coordinates[i];
          const mc = this.getMercatorCoordinate(coords);
          points.push([mc[0], mc[1]]);
        }
        const buffers = (this.options.createPlaneBuffer || defaultOptions$2.createPlaneBuffer)(
          points,
          this.options.widthSegments || 1,
          this.options.heightSegments || 1
        );
        return {
          indexes: buffers.elements.data,
          wireframeIndexes: buffers.wireframeElements.data,
          quadBuffer: createBuffer(
            this.gl,
            new Float32Array(buffers.position.data)
          ),
          quad64LowBuffer: createBuffer(
            this.gl,
            new Float32Array(buffers.positionLow.data)
          ),
          texCoordBuffer: createBuffer(this.gl, new Float32Array(buffers.uvs.data))
        };
      }
      getTextureData(data) {
        return new Promise((resolve, reject) => {
          if (data.type === "image" && data.url) {
            loadImage(data.url).then((image) => {
              const processedData = {
                width: image.width,
                height: image.height,
                texture: createTexture(
                  this.gl,
                  this.gl.LINEAR,
                  image,
                  image.width,
                  image.height
                ),
                ...this.initializeVertex(data.extent)
              };
              if (this.options.renderForm === "rg") {
                processedData.uMin = data.uMin;
                processedData.uMax = data.uMax;
                processedData.vMin = data.vMin;
                processedData.vMax = data.vMax;
              } else if (this.options.renderForm === "r") {
                processedData.min = data.min;
                processedData.max = data.max;
              } else {
                console.warn("This type is not supported temporarily");
              }
              resolve(processedData);
            }).catch((error) => reject(error));
          } else if (data.type === "jsonArray" && data.data) {
            const gfsData = data.data;
            let pos;
            if (data.extent) {
              pos = data.extent;
            } else {
              pos = [
                [gfsData[0].header.lo1, gfsData[0].header.la1],
                [gfsData[0].header.lo1, gfsData[0].header.la2],
                [gfsData[0].header.lo2, gfsData[0].header.la1],
                [gfsData[0].header.lo2, gfsData[0].header.la2]
              ];
            }
            const processedData = {
              width: gfsData[0].header.nx,
              height: gfsData[0].header.ny,
              ...this.initializeVertex(pos)
            };
            if (!this.worker) {
              this.worker = new WorkerFactory();
              this.worker.addEventListener("message", ({ data: payload }) => {
                if (this.options.renderForm === "rg") {
                  processedData.uMin = payload[1];
                  processedData.uMax = payload[2];
                  processedData.vMin = payload[3];
                  processedData.vMax = payload[4];
                  processedData.texture = createTexture(
                    this.gl,
                    this.gl.LINEAR,
                    new Uint8Array(payload[0]),
                    processedData.width,
                    processedData.height
                  );
                } else if (this.options.renderForm === "r") {
                  processedData.min = payload[1];
                  processedData.max = payload[2];
                  processedData.texture = createTexture(
                    this.gl,
                    this.gl.LINEAR,
                    new Uint8Array(payload[0]),
                    processedData.width,
                    processedData.height
                  );
                } else {
                  console.warn("This type is not supported temporarily");
                }
                resolve(processedData);
              });
            }
            if (this.options.renderForm === "rg") {
              let uComp;
              let vComp;
              gfsData.forEach((record) => {
                switch (record.header.parameterCategory + "," + record.header.parameterNumber) {
                  case "1,2":
                  case "2,2":
                    uComp = record;
                    break;
                  case "1,3":
                  case "2,3":
                    vComp = record;
                    break;
                }
              });
              const u = new Float32Array(uComp.data);
              const v = new Float32Array(vComp.data);
              this.worker.postMessage(["rg", u, v]);
            } else if (this.options.renderForm === "r") {
              const singleData = new Float32Array(gfsData[0].data);
              this.worker.postMessage(["r", singleData]);
            } else {
              console.warn("This type is not supported temporarily");
            }
          }
        });
      }
      setData(data, cb) {
        if (this.gl && data) {
          this.getTextureData(data).then((d) => {
            this.data = d;
            cb && cb(true);
            if (this.data) {
              this.initialize(this.gl);
            }
            if (this.options.triggerRepaint) {
              this.handleZoom();
              this.options.triggerRepaint();
            }
          }).catch((error) => {
            cb && cb(false);
            console.error(error);
          });
        }
      }
      getData() {
        return this.data;
      }
      getMercatorCoordinate([lng, lat]) {
        return [lng, lat];
      }
      prerender() {
      }
      render(matrix, offsetX, cameraParams) {
        if (this.data && this.drawCommand && this.data.texture && this.colorRampTexture) {
          const opacity = this.opacity;
          const uniforms = {
            u_opacity: isNumber(opacity) ? opacity : 1,
            u_image_res: [this.data.width, this.data.height],
            u_matrix: matrix,
            u_offset: isNumber(offsetX) ? offsetX : 0,
            u_color_ramp: this.colorRampTexture,
            u_color_range: this.colorRange,
            u_mapping_range: this.options.mappingRange || [0, 0]
          };
          if (cameraParams) {
            uniforms.u_cameraEye = cameraParams.cameraEye;
            uniforms.u_cameraEye64Low = cameraParams.cameraEye64Low;
          }
          if (this.options.renderForm === "rg") {
            uniforms.u_wind_min = [this.data.uMin, this.data.vMin];
            uniforms.u_wind_max = [this.data.uMax, this.data.vMax];
            uniforms.u_wind = this.data.texture;
            const speeds = [
              Math.sqrt(
                this.data.uMin * this.data.uMin + this.data.vMin * this.data.vMin
              ),
              Math.sqrt(
                this.data.uMin * this.data.uMin + this.data.vMax * this.data.vMax
              ),
              Math.sqrt(
                this.data.uMax * this.data.uMax + this.data.vMax * this.data.vMax
              ),
              Math.sqrt(
                this.data.uMax * this.data.uMax + this.data.vMin * this.data.vMin
              )
            ];
            const min = 0;
            const max = Math.max(...speeds);
            uniforms.u_display_range = this.options.displayRange || [min, max];
          } else if (this.options.renderForm === "r") {
            uniforms.u_range = [this.data.min, this.data.max];
            uniforms.u_image = this.data.texture;
            uniforms.u_display_range = this.options.displayRange || [
              uniforms.u_range[0] - 1,
              uniforms.u_range[1] + 1
            ];
          } else {
            console.warn("This type is not supported temporarily");
          }
          const depthEnabled = this.gl.isEnabled(this.gl.DEPTH_TEST);
          this.gl.enable(this.gl.DEPTH_TEST);
          this.gl.depthMask(true);
          this.gl.depthFunc(this.gl.LEQUAL);
          const data = this.options.wireframe ? this.data.wireframeIndexes : this.data.indexes;
          this.drawCommand.active().setUniforms(uniforms).setAttributes({
            instancePositions: {
              buffer: this.data.quadBuffer,
              numComponents: 3
            },
            instancePositions64Low: {
              buffer: this.data.quad64LowBuffer,
              numComponents: 3
            },
            a_texCoord: {
              buffer: this.data.texCoordBuffer,
              numComponents: 2
            }
          }).elements({
            data: new Uint32Array(data),
            primitive: this.options.wireframe ? this.gl.LINES : this.gl.TRIANGLES,
            count: data == null ? void 0 : data.length,
            usage: this.gl.STATIC_DRAW
          }).draw();
          if (!depthEnabled) {
            this.gl.disable(this.gl.DEPTH_TEST);
          }
        }
      }
      postrender() {
      }
      destroyData() {
        if (this.data) ;
      }
      destroyed() {
        this.destroyData();
        if (this.worker) {
          this.worker.terminate();
        }
      }
    }

    var drawFrag = "precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_wind;uniform vec2 u_wind_res;uniform vec4 u_wind_range;uniform vec2 u_color_range;uniform sampler2D u_color_ramp;varying vec2 v_particle_pos;vec2 decodeValue(const vec2 uv){vec4 u_color=texture2D(u_wind,uv);float u=u_wind_range[0]+((u_wind_range[1]-u_wind_range[0])*(u_color.r*255.0-1.0))/254.0;float v=u_wind_range[2]+((u_wind_range[3]-u_wind_range[2])*(u_color.g*255.0-1.0))/254.0;return vec2(u,v);}vec2 lookup_wind(const vec2 uv){vec2 px=1.0/u_wind_res;vec2 vc=(floor(uv*u_wind_res))*px;vec2 f=fract(uv*u_wind_res);vec2 tl=decodeValue(vc);vec2 tr=decodeValue(vc+vec2(px.x,0));vec2 bl=decodeValue(vc+vec2(0,px.y));vec2 br=decodeValue(vc+px);return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}void main(){vec2 velocity=lookup_wind(v_particle_pos);float speed_t=length(velocity);float value_t=(speed_t-u_color_range.x)/(u_color_range.y-u_color_range.x);vec2 ramp_pos=vec2(fract(16.0*value_t),floor(16.0*value_t)/16.0);vec4 color=texture2D(u_color_ramp,ramp_pos);gl_FragColor=vec4(floor(255.0*color*color.a)/255.0);}"; // eslint-disable-line

    var drawVert = "#define GLSLIFY 1\nattribute float a_index;uniform sampler2D u_particles_current;uniform sampler2D u_particles_next;uniform float u_particles_res;uniform vec2 u_world;uniform float u_zoom;uniform vec4 u_bbox;uniform float u_offset;uniform float u_width;uniform float u_aspectRatio;uniform mat4 u_matrix;varying vec2 v_particle_pos;const vec2 bitEnc=vec2(1.0,255.0);const vec2 bitDec=1.0/bitEnc;vec2 fromRGBA(const vec4 color){vec4 rounded_color=floor(color*255.0+0.5)/255.0;float x=dot(rounded_color.rg,bitDec);float y=dot(rounded_color.ba,bitDec);return vec2(x,y);}vec4 buildOffset(vec2 perp){vec2 normal=perp*u_width;normal.x/=u_aspectRatio;return vec4(normal,0.0,0.0);}vec4 buildOffset(vec2 perp,vec2 scale){vec2 normal=perp/scale*u_width;normal.x/=u_aspectRatio;return vec4(normal,0.0,0.0);}vec4 getPosWithProject(vec2 current_pos,vec2 next_pos,float v_index){vec4 currentProjected=u_matrix*vec4(current_pos,0.0,1.0);vec4 nextProjected=u_matrix*vec4(next_pos,0.0,1.0);vec2 currentScreen=currentProjected.xy/currentProjected.w*u_world;vec2 nextScreen=nextProjected.xy/nextProjected.w*u_world;vec2 dir=normalize(nextScreen-currentScreen);vec2 perp=vec2(-dir.y,dir.x);float d=length(nextScreen-currentScreen);vec4 pos=currentProjected;if(a_index-v_index*6.0==0.0){pos=currentProjected+buildOffset(perp);}else if(a_index-v_index*6.0==1.0){pos=currentProjected-buildOffset(perp);}else if(a_index-v_index*6.0==2.0){pos=nextProjected+buildOffset(perp);}else if(a_index-v_index*6.0==3.0){pos=nextProjected+buildOffset(perp);}else if(a_index-v_index*6.0==4.0){pos=nextProjected-buildOffset(perp);}else if(a_index-v_index*6.0==5.0){pos=currentProjected-buildOffset(perp);}if(d>20.0||d<0.01){pos.xy+=u_world*pow(2.0,u_zoom+1.0);}return pos;}void main(){float v_index=floor(a_index/6.0);float ux=fract(v_index/u_particles_res);float vy=floor(v_index/u_particles_res)/u_particles_res;vec4 current_color=texture2D(u_particles_current,vec2(ux,vy));vec4 next_color=texture2D(u_particles_next,vec2(ux,vy));vec2 v_current_particle_pos=fromRGBA(current_color);vec2 v_next_particle_pos=fromRGBA(next_color);vec2 vc_pos=u_bbox.xy+v_current_particle_pos*(u_bbox.zw-u_bbox.xy);vec2 nc_pos=u_bbox.xy+v_next_particle_pos*(u_bbox.zw-u_bbox.xy);v_particle_pos=mix(vc_pos,nc_pos,0.5);v_current_particle_pos=clamp(vc_pos,0.0,1.0)+vec2(u_offset,0.0);v_next_particle_pos=clamp(nc_pos,0.0,1.0)+vec2(u_offset,0.0);gl_PointSize=1.0;gl_Position=getPosWithProject(v_current_particle_pos,v_next_particle_pos,v_index);}"; // eslint-disable-line

    var screenFrag = "precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_screen;uniform float u_opacity;uniform float u_fade;varying vec2 v_tex_pos;void main(){vec4 color=texture2D(u_screen,v_tex_pos);gl_FragColor=vec4(floor(255.0*color*u_opacity*u_fade)/255.0);}"; // eslint-disable-line

    var screenVert = "#define GLSLIFY 1\nattribute vec2 a_pos;attribute vec2 a_tex_pos;varying vec2 v_tex_pos;void main(){v_tex_pos=a_tex_pos;gl_Position=vec4(a_pos*2.0-1.0,0,1);}"; // eslint-disable-line

    var updateFrag = "precision highp float;\n#define GLSLIFY 1\nuniform sampler2D u_wind;uniform sampler2D u_particles;uniform vec4 u_bbox;uniform vec2 u_wind_res;uniform vec4 u_wind_range;uniform float u_rand_seed;uniform float u_nodata;uniform float u_drop_rate;uniform float u_drop_rate_bump;uniform vec2 u_speed_factor;varying vec2 v_tex_pos;const vec2 bitEnc_0=vec2(1.0,255.0);const vec2 bitDec_0=1.0/bitEnc_0;vec4 toRGBA(const vec2 pos_0){vec2 rg=bitEnc_0*pos_0.x;rg=fract(rg);rg-=rg.yy*vec2(1.0/255.0,0.0);vec2 ba=bitEnc_0*pos_0.y;ba=fract(ba);ba-=ba.yy*vec2(1.0/255.0,0.0);return vec4(rg,ba);}const vec2 bitEnc_1=vec2(1.0,255.0);const vec2 bitDec_1=1.0/bitEnc_1;vec2 fromRGBA(const vec4 color){vec4 rounded_color=floor(color*255.0+0.5)/255.0;float x=dot(rounded_color.rg,bitDec_1);float y=dot(rounded_color.ba,bitDec_1);return vec2(x,y);}const vec3 rand_constants=vec3(12.9898,78.233,4375.85453);float rand(const vec2 co){float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}vec2 decodeValue(const vec2 uv){vec4 u_color=texture2D(u_wind,uv);float u=u_wind_range[0]+((u_wind_range[1]-u_wind_range[0])*(u_color.r*255.0-1.0))/254.0;float v=u_wind_range[2]+((u_wind_range[3]-u_wind_range[2])*(u_color.g*255.0-1.0))/254.0;return vec2(u,v);}vec2 getColor(const vec2 uv){vec2 px=1.0/(u_wind_res);vec2 vc=(floor(uv*(u_wind_res)))*px;vec4 u_color=texture2D(u_wind,vc);return vec2(u_color.r,u_color.g);}vec2 lookup_wind(const vec2 uv){vec2 px=1.0/u_wind_res;vec2 vc=(floor(uv*u_wind_res))*px;vec2 f=fract(uv*u_wind_res);vec2 tl=decodeValue(vc);vec2 tr=decodeValue(vc+vec2(px.x,0));vec2 bl=decodeValue(vc+vec2(0,px.y));vec2 br=decodeValue(vc+px);return mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);}void main(){vec4 color=texture2D(u_particles,v_tex_pos);vec2 pos=fromRGBA(color);vec2 global_pos=u_bbox.xy+pos*(u_bbox.zw-u_bbox.xy);vec2 alphas=getColor(global_pos);if(alphas.x<=u_nodata||alphas.y<=u_nodata){discard;}vec2 velocity=lookup_wind(global_pos);float speed_t=length(velocity);vec2 offset=vec2(velocity.x,-velocity.y)*u_speed_factor;pos=fract(1.0+pos+offset);vec2 seed=(pos+v_tex_pos)*u_rand_seed;float drop_rate=u_drop_rate+speed_t*u_drop_rate_bump;float drop=step(1.0-drop_rate,rand(seed));vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));pos=mix(pos,random_pos,drop);gl_FragColor=toRGBA(pos);}"; // eslint-disable-line

    var updateVert = "#define GLSLIFY 1\nattribute vec2 a_pos;varying vec2 v_tex_pos;void main(){v_tex_pos=a_pos;gl_Position=vec4(a_pos*2.0-1.0,0,1);}"; // eslint-disable-line

    const defaultOptions$1 = {
      callback: () => void 0
    };
    class Raf {
      constructor(options = {}) {
        this.options = {
          ...defaultOptions$1,
          ...options
        };
        this.reset();
        this.animate = this.animate.bind(this);
        this.onVisibilityChange = this.onVisibilityChange.bind(this);
      }
      reset() {
        this.animating = false;
        this.isVisible = true;
        if (this.raf !== void 0) {
          cancelAnimationFrame(this.raf);
        }
      }
      start() {
        if (this.animating) {
          return;
        }
        this.animating = true;
        document.addEventListener(
          "visibilitychange",
          this.onVisibilityChange,
          false
        );
        this.raf = requestAnimationFrame(this.animate);
      }
      stop() {
        this.reset();
        document.removeEventListener(
          "visibilitychange",
          this.onVisibilityChange,
          false
        );
      }
      animate() {
        if (!this.animating || !this.isVisible) {
          return;
        }
        this.options.callback((performance || Date).now());
        this.raf = requestAnimationFrame(this.animate);
      }
      onVisibilityChange() {
        this.isVisible = !document.hidden;
        if (this.isVisible) {
          this.reset();
          this.start();
        }
      }
    }

    const defaultOptions = {
      styleSpec: {
        color: [
          "interpolate",
          ["linear"],
          ["get", "value"],
          0,
          "#fff",
          100,
          "#fff"
        ],
        opacity: 1,
        numParticles: 65535
      },
      opacity: 1,
      lineWidth: 2,
      speedFactor: 1,
      fadeOpacity: 0.93,
      dropRate: 3e-3,
      dropRateBump: 2e-3
    };
    let uid = 0;
    class WindParticles {
      constructor(gl, options = {}) {
        this.gl = gl;
        this.uid = `WindParticles_${uid}`;
        uid++;
        if (!this.gl) {
          throw new Error("initialize error");
        }
        this.options = {
          ...defaultOptions,
          ...options
        };
        this.opacity = this.options.opacity || 1;
        this.visible = this.options.visible !== void 0 || true;
        this.alpha = 0.9;
        this.frameTime = 0;
        this.lastTime = 0;
        this.initialize(this.gl);
      }
      initialize(gl) {
        this.drawCommand = new Base(gl, drawVert, drawFrag);
        this.drawCommand.draw = function() {
          this.gl.drawArrays(this.primitive, 0, this.count);
        };
        this.updateCommand = new Base(gl, updateVert, updateFrag);
        this.updateCommand.draw = function() {
          this.gl.drawArrays(this.primitive, 0, 4);
        };
        this.screenCommand = new Base(gl, screenVert, screenFrag);
        this.screenCommand.draw = function() {
          this.gl.drawArrays(this.primitive, 0, 4);
        };
        this.fbo = gl.createFramebuffer();
        this.raf = new Raf({
          callback: () => {
            if (this.options.triggerRepaint) {
              this.options.triggerRepaint();
            }
          }
        });
        this.resize();
        this.buildColorRamp();
        if (typeof this.options.getZoom === "function") {
          const zoom = this.options.getZoom();
          this.setOpacity(
            createZoom(this.uid, zoom, "opacity", this.options.styleSpec)
          );
          this.numParticles = createZoom(
            this.uid,
            zoom,
            "numParticles",
            this.options.styleSpec
          );
        }
        this.start();
      }
      set numParticles(numParticles) {
        if (numParticles === void 0) {
          return;
        }
        const gl = this.gl;
        const particleRes = Math.ceil(Math.sqrt(numParticles));
        this.particleStateResolution = particleRes;
        this.privateNumParticles = particleRes * particleRes;
        const particleState = new Uint8Array(this.privateNumParticles * 4);
        for (let i = 0; i < particleState.length; i++) {
          particleState[i] = Math.floor(Math.random() * 256);
        }
        if (!this.currentParticleStateTexture) {
          this.currentParticleStateTexture = createTexture(
            gl,
            gl.NEAREST,
            particleState,
            particleRes,
            particleRes
          );
        } else {
          resizeTexture(
            gl,
            this.currentParticleStateTexture,
            particleRes,
            particleRes,
            particleState
          );
        }
        if (!this.nextParticleStateTexture) {
          this.nextParticleStateTexture = createTexture(
            gl,
            gl.NEAREST,
            particleState,
            particleRes,
            particleRes
          );
        } else {
          resizeTexture(
            gl,
            this.nextParticleStateTexture,
            particleRes,
            particleRes,
            particleState
          );
        }
        const num = this.privateNumParticles * 6;
        const particleIndices = new Float32Array(num);
        for (let i = 0; i < num; i++) {
          particleIndices[i] = i;
        }
        if (!this.particleIndexBuffer) {
          this.particleIndexBuffer = createBuffer(gl, particleIndices);
        } else {
          updateBufferData(gl, this.particleIndexBuffer, particleIndices);
        }
      }
      get numParticles() {
        return this.privateNumParticles;
      }
      updateOptions(options) {
        const styleSpec = options.styleSpec || {};
        this.options = {
          ...this.options,
          ...options,
          styleSpec: {
            ...this.options.styleSpec,
            ...styleSpec
          }
        };
        this.buildColorRamp();
        if (typeof this.options.getZoom === "function") {
          const zoom = this.options.getZoom();
          this.setOpacity(
            createZoom(this.uid, zoom, "opacity", this.options.styleSpec, true)
          );
          this.numParticles = createZoom(
            this.uid,
            zoom,
            "numParticles",
            this.options.styleSpec,
            true
          );
        }
      }
      setOpacity(opacity) {
        this.opacity = opacity;
      }
      getOpacity() {
        return this.opacity;
      }
      handleMoveend() {
        this.updateRenderState();
        clearScene(this.gl, [0, 0, 0, 0]);
      }
      handleMovestart() {
        this.alpha = 0;
      }
      handleZoom() {
        if (typeof this.options.getZoom === "function") {
          const zoom = this.options.getZoom();
          this.setOpacity(
            createZoom(this.uid, zoom, "opacity", this.options.styleSpec)
          );
          this.numParticles = createZoom(
            this.uid,
            zoom,
            "numParticles",
            this.options.styleSpec
          );
        }
      }
      buildColorRamp() {
        var _a;
        const { data, colorRange } = createLinearGradient(
          [],
          (_a = this.options.styleSpec) == null ? void 0 : _a.color
        );
        if (colorRange) {
          this.colorRange = colorRange;
        }
        if (data) {
          this.colorRampTexture = createTexture(
            this.gl,
            this.gl.NEAREST,
            data,
            16,
            16
          );
        }
      }
      drawTexture(matrix) {
        if (this.fbo && this.screenTexture && this.nextParticleStateTexture) {
          bindFramebuffer(this.gl, this.fbo, this.screenTexture);
          const depthEnabled = this.gl.isEnabled(this.gl.DEPTH_TEST);
          const blendingEnabled = this.gl.isEnabled(this.gl.BLEND);
          this.gl.disable(this.gl.DEPTH_TEST);
          this.gl.disable(this.gl.BLEND);
          this.screenCommand.active().resize(...this.size).setUniforms({
            u_screen: this.backgroundTexture,
            u_opacity: this.options.fadeOpacity,
            u_fade: 1
          }).setAttributes({
            a_pos: {
              buffer: this.data.backgroundBuffer,
              numComponents: 2
            },
            a_tex_pos: {
              buffer: this.data.backgroundTexCoordBuffer,
              numComponents: 2
            }
          }).setPrimitive(this.gl.TRIANGLE_STRIP).draw();
          if (depthEnabled) {
            this.gl.enable(this.gl.DEPTH_TEST);
          }
          if (blendingEnabled) {
            this.gl.enable(this.gl.BLEND);
          }
          this.drawParticles(matrix);
          bindFramebuffer(this.gl, null);
          [this.backgroundTexture, this.screenTexture] = [
            this.screenTexture,
            this.backgroundTexture
          ];
        }
      }
      drawScreen() {
        const depthEnabled = this.gl.isEnabled(this.gl.DEPTH_TEST);
        const blendingEnabled = this.gl.isEnabled(this.gl.BLEND);
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendColor(0, 0, 0, 0);
        this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
        this.screenCommand.active().resize().setUniforms({
          u_screen: this.screenTexture,
          u_opacity: this.visible ? this.opacity : 0,
          u_fade: this.alpha
        }).setAttributes({
          a_pos: {
            buffer: this.data.buffer,
            numComponents: 2
          },
          a_tex_pos: {
            buffer: this.data.texCoordBuffer,
            numComponents: 2
          }
        }).setPrimitive(this.gl.TRIANGLE_STRIP).draw();
        if (depthEnabled) {
          this.gl.enable(this.gl.DEPTH_TEST);
        }
        if (!blendingEnabled) {
          this.gl.disable(this.gl.BLEND);
        }
      }
      updateParticles() {
        if (this.fbo && this.currentParticleStateTexture && this.nextParticleStateTexture) {
          bindFramebuffer(this.gl, this.fbo, this.nextParticleStateTexture);
          const timeScale = this.options.speedFactor * 2.5;
          const depthEnabled = this.gl.isEnabled(this.gl.DEPTH_TEST);
          const blendingEnabled = this.gl.isEnabled(this.gl.BLEND);
          this.gl.disable(this.gl.DEPTH_TEST);
          this.gl.disable(this.gl.BLEND);
          this.updateCommand.active().resize(this.particleStateResolution, this.particleStateResolution).setUniforms({
            u_wind_res: [this.data.width, this.data.height],
            u_rand_seed: Math.random(),
            u_wind_range: [
              this.data.uMin,
              this.data.uMax,
              this.data.vMin,
              this.data.vMax
            ],
            u_drop_rate: this.options.dropRate,
            u_drop_rate_bump: this.options.dropRateBump,
            u_speed_factor: [
              timeScale * this.frameTime / this.size[0],
              timeScale * this.frameTime / this.size[1]
            ],
            u_wind: this.data.texture,
            u_bbox: this.renderExtent,
            nodata: this.data.nodata,
            u_particles: this.currentParticleStateTexture
          }).setAttributes({
            a_pos: {
              buffer: this.data.quadBuffer,
              numComponents: 2
            }
          }).setPrimitive(this.gl.TRIANGLE_STRIP).draw();
          if (depthEnabled) {
            this.gl.enable(this.gl.DEPTH_TEST);
          }
          if (blendingEnabled) {
            this.gl.enable(this.gl.BLEND);
          }
          [this.currentParticleStateTexture, this.nextParticleStateTexture] = [
            this.nextParticleStateTexture,
            this.currentParticleStateTexture
          ];
        }
      }
      drawParticles(matrix) {
        if (this.particleIndexBuffer && this.currentParticleStateTexture && this.nextParticleStateTexture) {
          const depthEnabled = this.gl.isEnabled(this.gl.DEPTH_TEST);
          const blendingEnabled = this.gl.isEnabled(this.gl.BLEND);
          this.gl.disable(this.gl.DEPTH_TEST);
          this.gl.disable(this.gl.BLEND);
          const zoom = this.options.getZoom();
          const worlds = this.options.getWorlds();
          for (let i = 0; i < worlds.length; i++) {
            this.drawCommand.active().setUniforms({
              u_width: this.options.lineWidth,
              u_world: this.size,
              u_matrix: matrix,
              u_zoom: zoom,
              u_bbox: this.renderExtent,
              u_offset: worlds[i],
              u_wind: this.data.texture,
              u_wind_res: [this.data.width, this.data.height],
              u_wind_range: [
                this.data.uMin,
                this.data.uMax,
                this.data.vMin,
                this.data.vMax
              ],
              u_color_ramp: this.colorRampTexture,
              u_color_range: this.colorRange,
              u_aspectRatio: this.size[0] / this.size[1],
              u_particles_current: this.currentParticleStateTexture,
              u_particles_next: this.nextParticleStateTexture,
              u_particles_res: this.particleStateResolution
            }).setAttributes({
              a_index: {
                buffer: this.particleIndexBuffer,
                numComponents: 1
              }
            }).setPrimitive(this.gl.TRIANGLES).runTimes(this.particleStateResolution ** 2 * 6).draw();
          }
          if (blendingEnabled) {
            this.gl.enable(this.gl.BLEND);
          }
          if (depthEnabled) {
            this.gl.enable(this.gl.DEPTH_TEST);
          }
        }
      }
      updateRenderState() {
        this.renderExtent = this.options.getExtent();
      }
      resize() {
        const gl = this.gl;
        this.size = this.options.getSize();
        this.updateRenderState();
        const emptyPixels = new Uint8Array(this.size[0] * this.size[1] * 4);
        if (!this.backgroundTexture) {
          this.backgroundTexture = createTexture(
            gl,
            gl.NEAREST,
            emptyPixels,
            this.size[0],
            this.size[1]
          );
        } else {
          resizeTexture(
            gl,
            this.backgroundTexture,
            this.size[0],
            this.size[1],
            emptyPixels
          );
        }
        if (!this.screenTexture) {
          this.screenTexture = createTexture(
            gl,
            gl.NEAREST,
            emptyPixels,
            this.size[0],
            this.size[1]
          );
        } else {
          resizeTexture(
            gl,
            this.screenTexture,
            this.size[0],
            this.size[1],
            emptyPixels
          );
        }
        if (this.fbo) {
          resizeFramebuffer(
            gl,
            this.fbo,
            this.size[0],
            this.size[1],
            this.screenTexture
          );
        }
      }
      start() {
        this.raf.start();
        if (this.options.triggerRepaint) {
          this.options.triggerRepaint();
        }
      }
      stop() {
        this.raf.stop();
        clearScene(this.gl, [0, 0, 0, 0]);
        if (this.options.triggerRepaint) {
          this.options.triggerRepaint();
        }
      }
      prerender(matrix) {
        if (this.data) {
          this.updateParticles();
          this.drawTexture(matrix);
          const now = 1e-3 * Date.now();
          this.frameTime = Math.min(now - (this.lastTime || 0), 0.05);
          this.lastTime = now;
        }
      }
      render() {
        if (this.data) {
          if (this.options.interacting()) {
            if (this.alpha < 1) {
              this.alpha += 3 * this.frameTime;
              if (this.alpha > 1 || !this.frameTime) {
                this.alpha = 1;
              }
            }
          }
          this.drawScreen();
        }
        return this;
      }
      initializeVertex(coordinates) {
        let i = 0;
        const len = coordinates.length;
        const instancePositions = new Float32Array(len * 2);
        for (; i < len; i++) {
          const coords = coordinates[i];
          const mc = this.getMercatorCoordinate(coords);
          instancePositions[i * 2] = mc[0];
          instancePositions[i * 2 + 1] = mc[1];
        }
        return {
          quadBuffer: createBuffer(
            this.gl,
            new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])
          ),
          buffer: createBuffer(this.gl, instancePositions),
          texCoordBuffer: createBuffer(
            this.gl,
            new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])
          ),
          backgroundBuffer: createBuffer(
            this.gl,
            new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])
          ),
          backgroundTexCoordBuffer: createBuffer(
            this.gl,
            new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])
          )
        };
      }
      getTextureData(data) {
        return new Promise((resolve, reject) => {
          if (data.type === "image" && data.url) {
            loadImage(data.url).then((image) => {
              const processedData = {
                width: image.width,
                height: image.height,
                texture: createTexture(
                  this.gl,
                  this.gl.LINEAR,
                  image,
                  image.width,
                  image.height
                ),
                nodata: data.nodata || 0,
                ...this.initializeVertex(data.extent)
              };
              processedData.uMin = data.uMin;
              processedData.uMax = data.uMax;
              processedData.vMin = data.vMin;
              processedData.vMax = data.vMax;
              resolve(processedData);
            }).catch((error) => reject(error));
          }
        });
      }
      setData(data, cb) {
        if (this.gl && data) {
          this.getTextureData(data).then((d) => {
            this.data = d;
            cb && cb(true);
            if (this.options.triggerRepaint) {
              this.options.triggerRepaint();
            }
          }).catch((error) => {
            cb && cb(false);
            console.error(error);
          });
        }
      }
      getData() {
        return this.data;
      }
      getMercatorCoordinate([lng, lat]) {
        return [lng, lat];
      }
      destroyData() {
        if (this.data) {
          const {
            texture,
            quadBuffer,
            buffer,
            texCoordBuffer,
            backgroundBuffer,
            backgroundTexCoordBuffer
          } = this.data;
          if (texture) {
            this.gl.deleteTexture(texture);
          }
          if (buffer) {
            this.gl.deleteBuffer(buffer);
          }
          if (quadBuffer) {
            this.gl.deleteBuffer(quadBuffer);
          }
          if (texCoordBuffer) {
            this.gl.deleteBuffer(texCoordBuffer);
          }
          if (backgroundBuffer) {
            this.gl.deleteBuffer(backgroundBuffer);
          }
          if (backgroundTexCoordBuffer) {
            this.gl.deleteBuffer(backgroundTexCoordBuffer);
          }
          delete this.data;
        }
      }
      destroyed() {
        this.stop();
        if (this.currentParticleStateTexture) {
          this.gl.deleteTexture(this.currentParticleStateTexture);
          this.currentParticleStateTexture = null;
        }
        if (this.nextParticleStateTexture) {
          this.gl.deleteTexture(this.nextParticleStateTexture);
          this.nextParticleStateTexture = null;
        }
        if (this.backgroundTexture) {
          this.gl.deleteTexture(this.backgroundTexture);
          this.backgroundTexture = null;
        }
        if (this.screenTexture) {
          this.gl.deleteTexture(this.screenTexture);
          this.screenTexture = null;
        }
        if (this.fbo) {
          this.gl.deleteFramebuffer(this.fbo);
          this.fbo = null;
        }
        this.destroyData();
      }
    }

    exports.ScalarFill = ScalarFill;
    exports.WindParticles = WindParticles;
    exports.bindAttribute = bindAttribute;
    exports.bindFramebuffer = bindFramebuffer;
    exports.bindTexture = bindTexture;
    exports.calcMinMax = calcMinMax;
    exports.clearScene = clearScene;
    exports.createBuffer = createBuffer;
    exports.createProgram = createProgram;
    exports.createShader = createShader;
    exports.createTexture = createTexture;
    exports.defaultOptions = defaultOptions$2;
    exports.defineShader = defineShader;
    exports.destroyTexture = destroyTexture;
    exports.findStopLessThanOrEqualTo = findStopLessThanOrEqualTo;
    exports.fp64LowPart = fp64LowPart;
    exports.getDevicePixelRatio = getDevicePixelRatio;
    exports.getEye = getEye;
    exports.getGlContext = getGlContext;
    exports.getPlaneBuffer = getPlaneBuffer;
    exports.injectShaderModule = injectShaderModule;
    exports.isNumber = isNumber;
    exports.isValide = isValide;
    exports.loadImage = loadImage;
    exports.mat4Invert = mat4Invert;
    exports.resizeCanvasSize = resizeCanvasSize;
    exports.resizeFramebuffer = resizeFramebuffer;
    exports.resizeTexture = resizeTexture;
    exports.transformMat4 = transformMat4;
    exports.updateBufferData = updateBufferData;

}));
//# sourceMappingURL=wind-gl-core.js.map
