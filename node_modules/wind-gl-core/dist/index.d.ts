declare function getDevicePixelRatio(): number;
/**
 * resize gl context
 * @link https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
 * @link https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-anti-patterns.html
 * @param canvas
 * @param pixelRatio
 * @returns {boolean}
 */
declare function resizeCanvasSize(canvas: HTMLCanvasElement, pixelRatio?: number): boolean;
/**
 * get gl context
 * @param canvas
 * @param glOptions
 * @returns {null}
 */
declare function getGlContext(canvas: HTMLCanvasElement, glOptions?: {}): WebGLRenderingContext | null;
/**
 * defines
 * @param shader
 * @param defines
 */
declare function defineShader(shader: string, defines: any): string;
/**
 * inject shader module
 * @param shader
 * @param modules
 */
declare function injectShaderModule(shader: string, modules?: any): string;
/**
 * create shader and compile shader
 * @param gl
 * @param type
 * @param source
 * @returns {WebGLShader}
 */
declare function createShader(gl: WebGLRenderingContext, type: GLenum, source: string): WebGLShader;
/**
 * create program from vertex and frag
 * @param gl
 * @param vertexShaderSource
 * @param fragmentShaderSource
 * @returns {WebGLProgram}
 */
declare function createProgram(gl: WebGLRenderingContext, vertexShaderSource: string, fragmentShaderSource: string): WebGLProgram | null;
/**
 * create 2d texture
 * @param gl
 * @param filter
 * @param data
 * @param width
 * @param height
 * @returns {WebGLTexture}
 */
declare function createTexture(gl: WebGLRenderingContext, filter: GLint, data: TexImageSource | Uint8Array, width: number, height: number): WebGLTexture | null;
declare function resizeTexture(gl: WebGLRenderingContext, texture: WebGLTexture, width: number, height: number, data: TexImageSource | Uint8Array): void;
/**
 * bind texture
 * @param gl
 * @param texture
 * @param unit
 */
declare function bindTexture(gl: WebGLRenderingContext, texture: WebGLTexture, unit: number): void;
/**
 * delete texture
 * @param gl
 * @param texture
 */
declare function destroyTexture(gl: WebGLRenderingContext, texture: WebGLTexture): void;
/**
 * create data buffer
 * @param gl
 * @param data
 * @returns {AudioBuffer | WebGLBuffer}
 */
declare function createBuffer(gl: WebGLRenderingContext, data: any): WebGLBuffer | null;
declare function updateBufferData(gl: WebGLRenderingContext, buffer: WebGLBuffer, data: any): WebGLBuffer;
/**
 * bind attribute
 * @param gl
 * @param buffer
 * @param attribute
 * @param numComponents
 */
declare function bindAttribute(gl: WebGLRenderingContext, buffer: WebGLBuffer, attribute: GLuint, numComponents: GLint): void;
/**
 * bind framebuffer
 * @param gl
 * @param framebuffer
 * @param texture
 */
declare function bindFramebuffer(gl: WebGLRenderingContext, framebuffer: WebGLFramebuffer | null, texture?: WebGLTexture): void;
declare function resizeFramebuffer(gl: WebGLRenderingContext, framebuffer: WebGLFramebuffer | null, width: number, height: number, texture?: WebGLTexture): void;
/**
 * clear scene
 * @param gl
 * @param color
 */
declare function clearScene(gl: WebGLRenderingContext, color: number[], depth?: number, stencil?: number, fbo?: WebGLFramebuffer): void;
/**
 * load image by url
 * @param src
 * @returns {Promise<Image>}
 */
declare function loadImage(src: string): Promise<HTMLImageElement>;
interface IPlaneBuffer {
    uvs: {
        data: number[];
        size: number;
    };
    elements: {
        data: number[];
        count: number;
    };
    wireframeElements: {
        data: number[];
        count: number;
    };
    position: {
        data: number[];
        size: number;
    };
    positionLow: {
        data: number[];
        size: number;
    };
}
declare function getPlaneBuffer(startX: number, endX: number, startY: number, endY: number, widthSegments: number, heightSegments: number): IPlaneBuffer;

interface IGFSItem {
    header: {
        parameterCategory: number | string;
        parameterNumber: number | string;
        dx: number;
        dy: number;
        nx: number;
        ny: number;
        lo1: number;
        lo2: number;
        la1: number;
        la2: number;
        [key: string]: any;
    };
    data: number[];
}
interface IOptions {
    renderForm?: 'rg' | 'r';
    styleSpec?: {
        'fill-color': any[];
        opacity: number | any[];
    };
    getZoom?: () => number;
    opacity?: number;
    triggerRepaint?: () => void;
    createPlaneBuffer?: (points: number[][], widthSegments: number, heightSegments: number) => IPlaneBuffer;
    injectShaderModules: {
        [key: string]: string;
    };
    displayRange?: [number, number];
    mappingRange?: [number, number];
    widthSegments?: number;
    heightSegments?: number;
    wireframe?: boolean;
}
interface IData$1 {
    width: number;
    height: number;
    uMin?: number;
    uMax?: number;
    vMin?: number;
    vMax?: number;
    min?: number;
    max?: number;
    texCoordBuffer: WebGLBuffer | null;
    quadBuffer: WebGLBuffer | null;
    quad64LowBuffer: WebGLBuffer | null;
    texture?: WebGLTexture | null;
    indexes?: number[] | number[][];
    wireframeIndexes?: number[] | number[][];
}
interface IJsonArrayData {
    type: 'jsonArray';
    data: IGFSItem[];
    extent?: Array<[number, number]>;
}
interface IImageData$1 {
    type: 'image';
    url: string;
    extent: Array<[number, number]>;
    uMin?: number;
    uMax?: number;
    vMin?: number;
    vMax?: number;
    min?: number;
    max?: number;
}
declare const defaultOptions: IOptions;
interface IScalarFill<T> {
    [key: string]: T;
}
declare class ScalarFill implements IScalarFill<any> {
    [index: string]: any;
    readonly gl: WebGLRenderingContext;
    data: IData$1;
    colorRampTexture: WebGLTexture | null;
    private uid;
    private options;
    private opacity;
    private colorRange;
    private worker;
    private drawCommand;
    constructor(gl: WebGLRenderingContext, options?: Partial<IOptions>);
    updateOptions(options: Partial<IOptions>): void;
    setFillColor(): void;
    setOpacity(opacity: number): void;
    handleZoom(): void;
    buildColorRamp(): void;
    initialize(gl: WebGLRenderingContext): void;
    initializeVertex(coordinates: number[][]): {
        indexes: number[];
        wireframeIndexes: number[];
        quadBuffer: WebGLBuffer | null;
        quad64LowBuffer: WebGLBuffer | null;
        texCoordBuffer: WebGLBuffer | null;
    };
    getTextureData(data: IJsonArrayData | IImageData$1): Promise<IData$1>;
    setData(data: IJsonArrayData | IImageData$1, cb?: (args?: boolean) => void): void;
    getData(): IData$1;
    getMercatorCoordinate([lng, lat]: [number, number]): [number, number];
    prerender(): void;
    render(matrix: number[], offsetX?: number, cameraParams?: {
        cameraEye: number[];
        cameraEye64Low: number[];
    }): void;
    postrender(): void;
    destroyData(): void;
    destroyed(): void;
}

interface IWindOptions {
    opacity: number;
    fadeOpacity: number;
    speedFactor: number;
    dropRate: number;
    dropRateBump: number;
    lineWidth: number;
    visible?: boolean;
    styleSpec?: {
        color: any[];
        opacity: number | any[];
        numParticles: number | any[];
    };
    getZoom: () => number;
    triggerRepaint?: () => void;
    getSize: () => [number, number];
    getExtent: () => [number, number, number, number];
    interacting: () => boolean;
    getWorlds: () => number[];
}
interface IImageData {
    type: 'image';
    url: string;
    extent: Array<[number, number]>;
    uMin?: number;
    uMax?: number;
    vMin?: number;
    vMax?: number;
    min?: number;
    max?: number;
    nodata?: number;
}
interface IData {
    width: number;
    height: number;
    uMin?: number;
    uMax?: number;
    vMin?: number;
    vMax?: number;
    min?: number;
    max?: number;
    nodata?: number;
    texCoordBuffer: WebGLBuffer | null;
    quadBuffer: WebGLBuffer | null;
    buffer: WebGLBuffer | null;
    backgroundBuffer: WebGLBuffer | null;
    backgroundTexCoordBuffer: WebGLBuffer | null;
    texture?: WebGLTexture | null;
}
declare class WindParticles {
    gl: WebGLRenderingContext;
    data: IData;
    private privateNumParticles;
    private particleStateResolution;
    private currentParticleStateTexture;
    private nextParticleStateTexture;
    private particleIndexBuffer;
    private backgroundTexture;
    private screenTexture;
    private drawCommand;
    private updateCommand;
    private screenCommand;
    private raf;
    private fbo;
    private colorRampTexture;
    private options;
    private opacity;
    private colorRange;
    private size;
    private renderExtent;
    private visible;
    private alpha;
    private frameTime;
    private lastTime;
    private readonly uid;
    constructor(gl: WebGLRenderingContext, options?: IWindOptions);
    initialize(gl: WebGLRenderingContext): void;
    set numParticles(numParticles: number);
    get numParticles(): number;
    updateOptions(options: Partial<IWindOptions>): void;
    setOpacity(opacity: number): void;
    getOpacity(): number;
    handleMoveend(): void;
    handleMovestart(): void;
    handleZoom(): void;
    buildColorRamp(): void;
    drawTexture(matrix: number[]): void;
    drawScreen(): void;
    updateParticles(): void;
    drawParticles(matrix: number[]): void;
    updateRenderState(): void;
    resize(): void;
    start(): void;
    stop(): void;
    prerender(matrix: number[]): void;
    render(): this;
    initializeVertex(coordinates: number[][]): {
        quadBuffer: WebGLBuffer | null;
        buffer: WebGLBuffer | null;
        texCoordBuffer: WebGLBuffer | null;
        backgroundBuffer: WebGLBuffer | null;
        backgroundTexCoordBuffer: WebGLBuffer | null;
    };
    getTextureData(data: IImageData): Promise<IData>;
    setData(data: IImageData, cb?: (args?: boolean) => void): void;
    getData(): IData;
    getMercatorCoordinate([lng, lat]: [number, number]): [number, number];
    destroyData(): void;
    destroyed(): void;
}

declare function calcMinMax(array: number[]): [number, number];
declare function isNumber(val: any): boolean;
declare function isValide(val: any): boolean;
declare function findStopLessThanOrEqualTo(stops: number[], input: number): number;
declare function fp64LowPart(x: number): number;
declare function mat4Invert(out: number[], a: number[]): number[] | null;
declare function transformMat4(out: number[], a: number[], m: number[]): number[];
declare function getEye(matrix: number[]): number[];

export { IGFSItem, IJsonArrayData, IOptions, IPlaneBuffer, IWindOptions, ScalarFill, WindParticles, bindAttribute, bindFramebuffer, bindTexture, calcMinMax, clearScene, createBuffer, createProgram, createShader, createTexture, defaultOptions, defineShader, destroyTexture, findStopLessThanOrEqualTo, fp64LowPart, getDevicePixelRatio, getEye, getGlContext, getPlaneBuffer, injectShaderModule, isNumber, isValide, loadImage, mat4Invert, resizeCanvasSize, resizeFramebuffer, resizeTexture, transformMat4, updateBufferData };
