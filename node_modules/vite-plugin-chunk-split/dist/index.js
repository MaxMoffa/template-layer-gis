"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chunkSplitPlugin = void 0;
const vite_1 = require("vite");
const assert_1 = __importDefault(require("assert"));
const path_1 = __importDefault(require("path"));
const staticImportScan_1 = require("./staticImportScan");
const helper_1 = require("./helper");
const SPLIT_DEFAULT_MODULES = {};
const resolveEntry = (name) => (0, vite_1.resolvePackageEntry)(name, (0, vite_1.resolvePackageData)(name, process.cwd(), true), true, {
    isBuild: true,
    isProduction: process.env.NODE_ENV === "production",
    isRequire: false,
    root: process.cwd(),
    preserveSymlinks: false,
});
const cache = new Map();
const wrapCustomSplitConfig = (manualChunks, customOptions) => {
    (0, assert_1.default)(typeof manualChunks === "function");
    const groups = Object.keys(customOptions);
    // Create cache ahead of time to decrease the cost of resolve.sync!
    const depsInGroup = {};
    for (const group of groups) {
        const packageInfo = customOptions[group];
        depsInGroup[group] = packageInfo
            .filter((item) => typeof item === "string")
            .map((item) => {
            try {
                return resolveEntry(item);
            }
            catch (err) {
                return "";
            }
        })
            .filter((_) => _.length > 0);
    }
    return (moduleId, { getModuleIds, getModuleInfo }) => {
        const isDepInclude = (id, depPaths, importChain) => {
            // compat windows
            id = (0, vite_1.normalizePath)(id);
            const key = `${id}-${depPaths.join("|")}`;
            // circular dependency
            if (importChain.includes(id)) {
                cache.set(key, false);
                return false;
            }
            if (cache.has(key)) {
                return cache.get(key);
            }
            // hit
            if (depPaths.includes(id)) {
                importChain.forEach((item) => cache.set(`${item}-${depPaths.join("|")}`, true));
                return true;
            }
            const moduleInfo = getModuleInfo(id);
            if (!moduleInfo || !moduleInfo.importers) {
                cache.set(key, false);
                return false;
            }
            const isInclude = moduleInfo.importers.some((importer) => isDepInclude(importer, depPaths, importChain.concat(id)));
            // set cache, important!
            cache.set(key, isInclude);
            return isInclude;
        };
        for (const group of groups) {
            const deps = depsInGroup[group];
            const packageInfo = customOptions[group];
            if (!(0, helper_1.isCSSIdentifier)(moduleId)) {
                if (moduleId.includes("node_modules") &&
                    deps.length &&
                    isDepInclude(moduleId, deps, [])) {
                    return group;
                }
                for (const rule of packageInfo) {
                    if (rule instanceof RegExp && rule.test(moduleId)) {
                        return group;
                    }
                }
            }
        }
        return manualChunks(moduleId, { getModuleIds, getModuleInfo });
    };
};
function chunkSplitPlugin(splitOptions = {
    strategy: "default",
}) {
    const { strategy = "default", customSplitting = {} } = splitOptions;
    let manualChunks;
    if (strategy === "all-in-one") {
        manualChunks = wrapCustomSplitConfig(() => {
            return null;
        }, customSplitting);
    }
    if (strategy === "default" || strategy === 'single-vendor') {
        manualChunks = wrapCustomSplitConfig((id, { getModuleInfo }) => {
            if (id.includes("node_modules") && !(0, helper_1.isCSSIdentifier)(id)) {
                if ((0, staticImportScan_1.staticImportedScan)(id, getModuleInfo, new Map(), [])) {
                    return "vendor";
                }
            }
        }, Object.assign(Object.assign({}, SPLIT_DEFAULT_MODULES), customSplitting));
    }
    if (strategy === "unbundle") {
        manualChunks = wrapCustomSplitConfig((id, { getModuleInfo }) => {
            if (id.includes("node_modules") && !(0, helper_1.isCSSIdentifier)(id)) {
                if ((0, staticImportScan_1.staticImportedScan)(id, getModuleInfo, new Map(), [])) {
                    return "vendor";
                }
                else {
                    return "async-vendor";
                }
            }
            const cwd = process.cwd();
            if (!id.includes("node_modules") && !(0, helper_1.isCSSIdentifier)(id)) {
                const extname = path_1.default.extname(id);
                return (0, vite_1.normalizePath)(path_1.default.relative(cwd, id).replace(extname, ""));
            }
            return;
        }, Object.assign(Object.assign({}, SPLIT_DEFAULT_MODULES), customSplitting));
    }
    return {
        name: "vite-plugin-chunk-split",
        config() {
            return {
                build: {
                    rollupOptions: {
                        output: {
                            manualChunks,
                        },
                    },
                },
            };
        },
    };
}
exports.chunkSplitPlugin = chunkSplitPlugin;
//# sourceMappingURL=index.js.map