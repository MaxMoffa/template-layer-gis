import * as mapboxgl from 'mapbox-gl';
import { IOptions as IOptions$1, Field, IField } from 'wind-core';
export { Field } from 'wind-core';
import { IOptions, IWindOptions as IWindOptions$1 } from 'wind-gl-core';

/**
 * @desc mapbox dom 图层
 * @tip: 为什么实现这个图层，本身mapbox-gl支持 canvas source，但是经过测试添加此图层性能会急剧下降
 */

declare class Overlay {
    map: mapboxgl.Map;
    options: any;
    protected canvas: HTMLCanvasElement | null;
    private canvas2;
    private devicePixelRatio;
    type: string;
    renderingMode: string;
    id: string | number;
    constructor(id: string | number, options?: {});
    onAdd(map: mapboxgl.Map): void;
    resizeCanvas(canvas: HTMLCanvasElement): void;
    initialize(): HTMLCanvasElement;
    render(): void;
    project(coordinates: [number, number]): number[];
    unproject(pixel: [number, number]): number[];
    intersectsCoordinate(coordinate: [number, number]): boolean;
    clear(): void;
    setMap(map: mapboxgl.Map): this;
    getMap(): mapboxgl.Map;
    addTo(map: mapboxgl.Map): void;
    remove(): void;
}

interface IScalarFillOptions extends IOptions {
    wrapX: boolean;
}
declare class ScalarFill {
    gl: WebGLRenderingContext;
    map: mapboxgl.Map;
    id: string;
    type: string;
    renderingMode: '2d' | '3d';
    private options;
    private data;
    private scalarFill;
    constructor(id: string, data: any, options?: Partial<IScalarFillOptions>);
    handleZoom(): void;
    initialize(): void;
    updateOptions(options: Partial<IScalarFillOptions>): void;
    onAdd(map: mapboxgl.Map, gl: WebGLRenderingContext): void;
    setData(data: any): Promise<unknown>;
    onRemove(map: mapboxgl.Map): void;
    getWrappedWorlds(): number[];
    render(gl: WebGLRenderingContext, matrix: number[]): void;
}

interface IParticlesOptions extends IWindOptions$1 {
    wrapX: boolean;
}
declare class Particles {
    private gl;
    map: any;
    id: string;
    type: string;
    renderingMode: '2d' | '3d';
    private options;
    private data;
    private layer;
    constructor(id: string, data: any, options?: Partial<IParticlesOptions>);
    updateOptions(options: Partial<IWindOptions$1>): void;
    handleZoom(): void;
    resize(): void;
    handleMovestart(): void;
    handleMoveend(): void;
    initialize(): void;
    onAdd(map: mapboxgl.Map, gl: WebGLRenderingContext): void;
    setData(data: any): Promise<unknown>;
    onRemove(map: mapboxgl.Map): void;
    getWrappedWorlds(): number[];
    prerender(gl: WebGLRenderingContext, matrix: number[]): void;
    render(gl: WebGLRenderingContext, matrix: number[]): void;
}

interface IWindOptions extends IOptions$1 {
    windOptions: Partial<IOptions$1>;
    fieldOptions: any;
    [key: string]: any;
}
declare class WindLayer extends Overlay {
    options: IWindOptions;
    private field;
    private wind;
    constructor(id: string | number, data: any, options?: any);
    onAdd(map: mapboxgl.Map): void;
    handleResize(): void;
    registerEvents(): void;
    unregisterEvents(): void;
    stop(): void;
    render(): void;
    remove(): void;
    pickWindOptions(): void;
    /**
     * get wind layer data
     */
    getData(): Field | undefined;
    /**
     * set layer data
     * @param data
     * @param options
     * @returns {WindLayer}
     */
    setData(data: any, options?: Partial<IField>): this;
    setWindOptions(options: Partial<IOptions$1>): void;
    getWindOptions(): Partial<IOptions$1>;
}

export { IWindOptions, Particles, ScalarFill, WindLayer, WindLayer as default };
