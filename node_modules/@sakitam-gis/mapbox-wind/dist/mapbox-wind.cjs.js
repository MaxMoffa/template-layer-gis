'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var windCore = require('wind-core');
var mapboxgl = require('mapbox-gl');
var windGlCore = require('wind-gl-core');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var mapboxgl__namespace = /*#__PURE__*/_interopNamespaceDefault(mapboxgl);

function removeDomNode(node) {
  if (!node) {
    return null;
  }
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
  return node;
}
class Overlay {
  constructor(id, options = {}) {
    if (!id) {
      throw Error("layer id must be specified");
    }
    this.id = id;
    this.options = options;
    this.canvas = null;
    this.canvas2 = null;
    this.devicePixelRatio = this.options.devicePixelRatio || (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI);
    this.render = this.render.bind(this);
    this.type = "custom";
    this.renderingMode = "2d";
  }
  onAdd(map) {
    this.setMap(map);
    this.canvas = this.initialize();
    if (this.options.doubleBuffer) {
      this.canvas2 = this.initialize();
    }
  }
  resizeCanvas(canvas) {
    const mapboxCanvas = this.map.getCanvas();
    const { width, height } = this.map.transform;
    const pixel = this.devicePixelRatio;
    canvas.width = width * pixel;
    canvas.height = height * pixel;
    canvas.style.width = mapboxCanvas.style.width;
    canvas.style.height = mapboxCanvas.style.height;
  }
  initialize() {
    const canvasContainer = this.map.getCanvasContainer();
    const mapboxCanvas = this.map.getCanvas();
    const canvasOverlay = document.createElement("canvas");
    const { width, height } = this.map.transform;
    const pixel = this.devicePixelRatio;
    canvasOverlay.width = width * pixel;
    canvasOverlay.height = height * pixel;
    canvasOverlay.style.position = "absolute";
    canvasOverlay.className = "mapbox-overlay-canvas";
    canvasOverlay.style.width = mapboxCanvas.style.width;
    canvasOverlay.style.height = mapboxCanvas.style.height;
    canvasContainer.appendChild(canvasOverlay);
    return canvasOverlay;
  }
  render() {
  }
  project(coordinates) {
    if (this.map !== void 0) {
      const lnglat = this.map.project(new mapboxgl__namespace.LngLat(coordinates[0], coordinates[1]));
      const x = lnglat.x;
      const y = lnglat.y;
      return [
        x * this.devicePixelRatio,
        y * this.devicePixelRatio
      ];
    }
    return coordinates;
  }
  unproject(pixel) {
    if (this.map !== void 0) {
      const lnglat = this.map.unproject(new mapboxgl__namespace.Point(pixel[0], pixel[1]));
      return [lnglat.lng, lnglat.lat];
    }
    return pixel;
  }
  intersectsCoordinate(coordinate) {
    var _a, _b;
    const bounds = this.map.getBounds();
    const latRange = (_b = (_a = this.map) == null ? void 0 : _a.transform) == null ? void 0 : _b.latRange;
    if (latRange) {
      if (coordinate[1] > latRange[1] || coordinate[1] < latRange[0])
        return false;
    }
    return bounds.contains(new mapboxgl__namespace.LngLat(coordinate[0], coordinate[1]));
  }
  clear() {
    if (this.canvas) {
      const ctx = this.canvas.getContext("2d");
      ctx && ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    if (this.canvas2) {
      const ctx = this.canvas2.getContext("2d");
      ctx && ctx.clearRect(0, 0, this.canvas2.width, this.canvas2.height);
    }
  }
  setMap(map) {
    this.map = map;
    return this;
  }
  getMap() {
    return this.map;
  }
  addTo(map) {
    this.onAdd(map);
  }
  remove() {
    if (this.canvas) {
      removeDomNode(this.canvas);
      this.canvas = null;
    }
    if (this.canvas2) {
      removeDomNode(this.canvas2);
      this.canvas2 = null;
    }
  }
}

function getCoords$1([lng, lat]) {
  const mercatorCoordinate = mapboxgl__namespace.MercatorCoordinate.fromLngLat({
    lng,
    lat
  });
  return [mercatorCoordinate.x, mercatorCoordinate.y];
}
class ScalarFill {
  constructor(id, data, options) {
    this.id = id;
    this.type = "custom";
    this.renderingMode = "3d";
    this.options = {
      ...options || {}
    };
    this.data = data;
    this.handleZoom = this.handleZoom.bind(this);
  }
  handleZoom() {
    if (this.scalarFill) {
      this.scalarFill.handleZoom();
    }
  }
  initialize() {
    if (!this.scalarFill && this.gl) {
      this.scalarFill = new windGlCore.ScalarFill(this.gl, {
        opacity: this.options.opacity,
        renderForm: this.options.renderForm,
        styleSpec: this.options.styleSpec,
        displayRange: this.options.displayRange,
        mappingRange: this.options.mappingRange,
        widthSegments: this.options.widthSegments,
        heightSegments: this.options.heightSegments,
        wireframe: this.options.wireframe,
        createPlaneBuffer: this.options.createPlaneBuffer,
        getZoom: () => this.map.getZoom(),
        triggerRepaint: () => {
          this.map.triggerRepaint();
        },
        injectShaderModules: {
          "#modules-transformZ": `
const float MATH_PI = 3.141592653589793;
const float earthRadius = 6371008.8;
const float earthCircumfrence = 2.0 * MATH_PI * earthRadius;

            float latFromMercatorY(float y) {
  float y2 = 180.0 - y * 360.0;
  return 360.0 / MATH_PI * atan(exp(y2 * MATH_PI / 180.0)) - 90.0;
}

float circumferenceAtLatitude(float latitude) {
  return earthCircumfrence * cos(latitude * MATH_PI / 180.0);
}

float mercatorScale(float lat) {
  return 1.0 / cos(lat * MATH_PI / 180.0);
}

float transformZ(float value, vec3 pos) {
  float mercatorY = pos.y;
  //  float scale = circumferenceAtLatitude(latFromMercatorY(mercatorY));
  float scale = earthCircumfrence * mercatorScale(latFromMercatorY(mercatorY));

  return value / scale;
}
          `,
          "#modules-project": `
gl_Position = u_matrix * vec4(pos.xy + vec2(u_offset, 0.0), pos.z + z, pos.w);
gl_Position.w += u_cameraEye.w;
    `
        }
      });
      this.scalarFill.getMercatorCoordinate = getCoords$1;
      this.map.on("zoom", this.handleZoom);
    }
    if (this.data) {
      this.setData(this.data);
    }
  }
  updateOptions(options) {
    this.options = {
      ...this.options,
      ...options || {}
    };
    if (this.scalarFill) {
      this.scalarFill.updateOptions(options);
    }
  }
  onAdd(map, gl) {
    this.gl = gl;
    this.map = map;
    if (this.map) {
      this.initialize();
    }
  }
  setData(data) {
    return new Promise((resolve, reject) => {
      this.data = data;
      if (this.data && this.scalarFill) {
        this.scalarFill.setData(this.data, (status) => {
          if (status) {
            resolve(true);
          } else {
            reject(false);
          }
        });
      } else {
        resolve(false);
      }
    });
  }
  onRemove(map) {
    if (this.scalarFill) {
      this.scalarFill.destroyed();
      this.scalarFill = null;
    }
    delete this.gl;
    delete this.map;
    map.off("zoom", this.handleZoom);
  }
  getWrappedWorlds() {
    const result = [0];
    if (this.options.wrapX) {
      const { width, height } = this.map.transform;
      const utl = this.map.transform.pointCoordinate(new mapboxgl__namespace.Point(0, 0));
      const utr = this.map.transform.pointCoordinate(
        new mapboxgl__namespace.Point(width, 0)
      );
      const ubl = this.map.transform.pointCoordinate(
        new mapboxgl__namespace.Point(width, height)
      );
      const ubr = this.map.transform.pointCoordinate(
        new mapboxgl__namespace.Point(0, height)
      );
      const w0 = Math.floor(Math.min(utl.x, utr.x, ubl.x, ubr.x));
      const w1 = Math.floor(Math.max(utl.x, utr.x, ubl.x, ubr.x));
      const extraWorldCopy = 1;
      for (let w = w0 - extraWorldCopy; w <= w1 + extraWorldCopy; w++) {
        if (w === 0) {
          continue;
        }
        result.push(w);
      }
    }
    return result;
  }
  render(gl, matrix) {
    const cameraEye = windGlCore.getEye(matrix);
    const cameraEye64Low = cameraEye.map((item) => windGlCore.fp64LowPart(item));
    if (this.data && this.scalarFill) {
      const worlds = this.getWrappedWorlds();
      for (let i = 0; i < worlds.length; i++) {
        this.scalarFill.render(matrix, worlds[i], {
          cameraEye,
          cameraEye64Low
        });
      }
    }
  }
}

function getCoords([lng, lat]) {
  const mercatorCoordinate = mapboxgl__namespace.MercatorCoordinate.fromLngLat({
    lng,
    lat
  });
  return [mercatorCoordinate.x, mercatorCoordinate.y];
}
class Particles {
  constructor(id, data, options) {
    this.id = id;
    this.type = "custom";
    this.renderingMode = "2d";
    this.options = {
      ...options || {}
    };
    this.data = data;
    this.resize = this.resize.bind(this);
    this.handleZoom = this.handleZoom.bind(this);
    this.handleMovestart = this.handleMovestart.bind(this);
    this.handleMoveend = this.handleMoveend.bind(this);
  }
  updateOptions(options) {
    this.options = {
      ...this.options,
      ...options || {}
    };
    if (this.layer) {
      this.layer.updateOptions(options);
    }
  }
  handleZoom() {
    if (this.layer) {
      this.layer.handleZoom();
    }
  }
  resize() {
    if (this.layer) {
      this.layer.resize();
    }
  }
  handleMovestart() {
    if (this.layer) {
      this.layer.handleMovestart();
    }
  }
  handleMoveend() {
    if (this.layer) {
      this.layer.handleMoveend();
    }
  }
  initialize() {
    if (!this.layer && this.gl) {
      this.layer = new windGlCore.WindParticles(this.gl, {
        getZoom: () => this.map.getZoom(),
        triggerRepaint: () => {
          this.map.triggerRepaint();
        },
        getExtent: () => {
          const bounds = this.map.getBounds().toArray();
          let xmin = bounds[0][0];
          const ymin = bounds[0][1];
          let xmax = bounds[1][0];
          const ymax = bounds[1][1];
          const worlds = this.getWrappedWorlds();
          if (worlds.length > 1) {
            xmin = -180;
            xmax = 180;
          } else {
            if (xmin < -180) {
              xmin = -180;
            }
            if (xmax > 180) {
              xmax = 180;
            }
          }
          const p0 = mapboxgl__namespace.MercatorCoordinate.fromLngLat(
            new mapboxgl__namespace.LngLat(xmin, ymax)
          );
          const p1 = mapboxgl__namespace.MercatorCoordinate.fromLngLat(
            new mapboxgl__namespace.LngLat(xmax, ymin)
          );
          return [p0.x, p0.y, p1.x, p1.y];
        },
        getSize: () => {
          return [
            this.map.transform.size.x,
            this.map.transform.size.y
          ];
        },
        interacting: () => {
          return !this.map.painter.options.moving && !this.map.painter.options.rotating && !this.map.painter.options.zooming;
        },
        getWorlds: () => this.getWrappedWorlds(),
        ...this.options
      });
      this.layer.getMercatorCoordinate = getCoords;
      this.map.on("zoom", this.handleZoom);
      this.map.on("movestart", this.handleMovestart);
      this.map.on("resize", this.resize);
      this.map.on("moveend", this.handleMoveend);
    }
    if (this.data) {
      this.setData(this.data);
    }
  }
  onAdd(map, gl) {
    this.gl = gl;
    this.map = map;
    if (this.map) {
      this.initialize();
    }
  }
  setData(data) {
    return new Promise((resolve, reject) => {
      this.data = data;
      if (this.data && this.layer) {
        this.layer.setData(this.data, (status) => {
          if (status) {
            resolve(true);
          } else {
            reject(false);
          }
        });
      } else {
        resolve(false);
      }
    });
  }
  onRemove(map) {
    if (this.layer) {
      this.layer.destroyed();
      this.layer = null;
    }
    map.off("zoom", this.handleZoom);
    map.off("movestart", this.handleMovestart);
    map.off("resize", this.resize);
    map.off("moveend", this.handleMoveend);
    delete this.gl;
    delete this.map;
  }
  getWrappedWorlds() {
    const result = [0];
    if (this.options.wrapX) {
      const { width, height } = this.map.transform;
      const utl = this.map.transform.pointCoordinate(new mapboxgl__namespace.Point(0, 0));
      const utr = this.map.transform.pointCoordinate(
        new mapboxgl__namespace.Point(width, 0)
      );
      const ubl = this.map.transform.pointCoordinate(
        new mapboxgl__namespace.Point(width, height)
      );
      const ubr = this.map.transform.pointCoordinate(
        new mapboxgl__namespace.Point(0, height)
      );
      const w0 = Math.floor(Math.min(utl.x, utr.x, ubl.x, ubr.x));
      const w1 = Math.floor(Math.max(utl.x, utr.x, ubl.x, ubr.x));
      const extraWorldCopy = 0;
      for (let w = w0 - extraWorldCopy; w <= w1 + extraWorldCopy; w++) {
        if (w === 0) {
          continue;
        }
        result.push(w);
      }
    }
    return result;
  }
  prerender(gl, matrix) {
    if (this.data && this.layer) {
      this.layer.prerender(matrix);
    }
  }
  render(gl, matrix) {
    if (this.data && this.layer) {
      this.layer.render(matrix);
    }
  }
}

const defaultConfig = {
  doubleBuffer: false,
  windOptions: windCore.defaultOptions
};
class WindLayer extends Overlay {
  constructor(id, data, options = {}) {
    super(id, { ...defaultConfig, ...options });
    this.pickWindOptions();
    if (data) {
      this.setData(data, options.fieldOptions);
    }
    this.stop = this.stop.bind(this);
    this.render = this.render.bind(this);
    this.handleResize = this.handleResize.bind(this);
  }
  onAdd(map) {
    super.onAdd(map);
    if (!this.map) {
      throw new Error("map is null");
    }
    if (this.canvas !== null) {
      this.render();
      this.registerEvents();
    }
  }
  handleResize() {
    if (this.canvas) {
      this.resizeCanvas(this.canvas);
    }
    this.render();
  }
  registerEvents() {
    this.map.on("resize", this.handleResize);
    this.map.on("movestart", this.stop);
    this.map.on("moveend", this.render);
    this.map.on("zoomstart", this.stop);
    this.map.on("zoomend", this.render);
    this.map.on("rotatestart", this.stop);
    this.map.on("rotateend", this.render);
    this.map.on("pitchstart", this.stop);
    this.map.on("pitchend", this.render);
  }
  unregisterEvents() {
    this.map.off("resize", this.handleResize);
    this.map.off("movestart", this.stop);
    this.map.off("moveend", this.render);
    this.map.off("zoomstart", this.stop);
    this.map.off("zoomend", this.render);
    this.map.off("rotatestart", this.stop);
    this.map.off("rotateend", this.render);
    this.map.off("pitchstart", this.stop);
    this.map.off("pitchend", this.render);
  }
  stop() {
    if (this.wind) {
      this.wind.clearCanvas();
    }
  }
  render() {
    if (!this.map) {
      return;
    }
    const opt = this.getWindOptions();
    if (!this.wind && this.map && this.canvas !== null) {
      const ctx = this.canvas.getContext("2d");
      if (!ctx) {
        console.error("create canvas context failed");
        return;
      }
      const data = this.getData();
      this.wind = new windCore.WindCore(ctx, opt, data);
      this.wind.project = this.project.bind(this);
      this.wind.unproject = this.unproject.bind(this);
      this.wind.intersectsCoordinate = this.intersectsCoordinate.bind(this);
      this.wind.postrender = () => {
      };
    }
    this.wind.prerender();
    this.wind.render();
  }
  remove() {
    super.remove();
    if (this.wind) {
      this.wind.stop();
    }
    this.unregisterEvents();
  }
  pickWindOptions() {
    Object.keys(windCore.defaultOptions).forEach((key) => {
      if (this.options && key in this.options) {
        if (this.options.windOptions === void 0) {
          this.options.windOptions = {};
        }
        this.options.windOptions[key] = this.options[key];
      }
    });
  }
  getData() {
    return this.field;
  }
  setData(data, options = {}) {
    var _a;
    if (data && data.checkFields && data.checkFields()) {
      this.field = data;
    } else if (windCore.isArray(data)) {
      this.field = windCore.formatData(data, options);
    } else {
      console.error("Illegal data");
    }
    if (this.field) {
      (_a = this == null ? void 0 : this.wind) == null ? void 0 : _a.updateData(this.field);
    }
    return this;
  }
  setWindOptions(options) {
    const beforeOptions = this.options.windOptions || {};
    this.options = windCore.assign(this.options, {
      windOptions: windCore.assign(beforeOptions, options || {})
    });
    if (this.wind) {
      const windOptions = this.options.windOptions;
      this.wind.setOptions(windOptions);
      this.wind.prerender();
    }
  }
  getWindOptions() {
    return this.options.windOptions || {};
  }
}

Object.defineProperty(exports, 'Field', {
  enumerable: true,
  get: function () { return windCore.Field; }
});
exports.Particles = Particles;
exports.ScalarFill = ScalarFill;
exports.WindLayer = WindLayer;
exports.default = WindLayer;
//# sourceMappingURL=mapbox-wind.cjs.js.map
